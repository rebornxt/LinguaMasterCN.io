<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HanziFlow - Learn Chinese</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Serif+SC:wght@400;500;700&family=Noto+Serif+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-red: #B91C1C; 
            --primary-red-darker: #991B1B;
            --accent-gold: #D97706; 
            --accent-gold-darker: #B08D57;
            --bg-main: #FDFCF8; 
            --bg-panel: #FFFFFF; 
            --bg-card: #FFFFFF;
            --bg-card-back: #FAF7F0; 
            --text-primary: #2C3E50; 
            --text-secondary: #7F8C8D; 
            --border-color: #E0E0E0; 
            --border-accent: var(--accent-gold);
            --shadow-soft: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-medium: 0 5px 15px rgba(0,0,0,0.1);
        }
        body {
            /* Added Noto Serif SC and TC to the body's font stack for general UI text */
            font-family: 'Inter', 'Noto Serif SC', 'Noto Serif TC', 'Noto Sans SC', sans-serif; 
            overscroll-behavior-y: contain; 
            background-color: var(--bg-main); color: var(--text-primary);
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        /* Specific classes for main Chinese characters in flashcards/quizzes */
        .chinese-char { 
            font-family: 'Noto Serif SC', 'Noto Serif TC', 'Noto Sans SC', serif; /* Prioritize Serif for these */
            font-size: 3rem; line-height: 1.3; min-height: 3.2rem; color: var(--text-primary); font-weight: 500; 
        }
        .chinese-char-quiz { 
            font-family: 'Noto Serif SC', 'Noto Serif TC', 'Noto Sans SC', serif; /* Prioritize Serif for these */
            font-size: 2.5rem; line-height: 1.3; min-height: 2.8rem; color: var(--text-primary); font-weight: 500;
        }
        .pinyin-text { font-family: 'Inter', sans-serif; font-size: 1rem; color: var(--text-secondary); min-height: 1.2rem; margin-top: 0.35rem; }
        .translation-text { font-family: 'Inter', sans-serif; font-size: 1.1rem; min-height: 1.3rem; color: var(--text-primary); }
        
        .flip-card { perspective: 1000px; }
        .flip-card-inner { 
            position: relative; width: 100%; height: 100%; text-align: center; 
            transition: transform 0.5s; 
            transform-style: preserve-3d; 
        }
        .flip-card.no-flip-animation .flip-card-inner {
            transition: none; 
        }
        .flip-card.flipped .flip-card-inner { transform: rotateY(180deg); }
        
        .flip-card-front, .flip-card-back {
            position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden;
            display: flex; flex-direction: column; align-items: center; padding: 20px; 
            border-radius: 16px; box-shadow: var(--shadow-medium);
            border: 1px solid var(--border-color);
        }
        .flip-card-front { background-color: var(--bg-card); justify-content: center; }
        .flip-card-back { 
            background-color: var(--bg-card-back); 
            transform: rotateY(180deg); 
            justify-content: space-between; 
        }
        
        .btn {
            padding: 0.6rem 1rem; 
            border-radius: 8px; font-weight: 500; 
            transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s, transform 0.15s;
            cursor: pointer; border: 1px solid transparent; text-align: center; 
            display: inline-flex; align-items: center; justify-content: center;
            box-shadow: var(--shadow-soft);
            font-size: 0.875rem; 
        }
        .btn-lg { 
             padding: 0.75rem 1.5rem;
             font-size: 0.95rem;
        }
        .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.12); }
        .btn:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; transform: none;}

        .btn-primary-theme { background-color: var(--primary-red); color: white; }
        .btn-primary-theme:hover:not(:disabled) { background-color: var(--primary-red-darker); }
        
        .btn-secondary-theme { background-color: var(--accent-gold); color: white; }
        .btn-secondary-theme:hover:not(:disabled) { background-color: var(--accent-gold-darker); }

        .btn-danger-theme { background-color: #C0392B; color: white; } 
        .btn-danger-theme:hover:not(:disabled) { background-color: #A93226; }

        .btn-outline-theme { 
            background-color: transparent; color: var(--primary-red); border-color: var(--primary-red); 
        }
        .btn-outline-theme:hover:not(:disabled) { background-color: rgba(185, 28, 28, 0.05); color: var(--primary-red-darker); border-color: var(--primary-red-darker);}
        
        .btn-subtle-outline {
            background-color: transparent; color: var(--text-secondary); border-color: var(--border-color);
        }
        .btn-subtle-outline:hover:not(:disabled) { background-color: var(--subtle-bg); border-color: var(--accent-gold); color: var(--accent-gold);}


        .btn-toggle.active { background-color: var(--accent-gold); color: white; border-color: var(--accent-gold); }
        .btn-toggle-group { gap: 0.25rem; }
        .btn-toggle-group button { background-color: var(--bg-card); color: var(--text-secondary); border: 1px solid var(--border-color); }
        .btn-toggle-group button:hover:not(.active):not(:disabled) { background-color: var(--subtle-bg); border-color: var(--accent-gold-darker); }

        .quiz-choice.correct { background-color: #D1FAE5; border-color: #10B981; color: #065F46; }
        .quiz-choice.incorrect { background-color: #FEE2E2; border-color: #EF4444; color: #991B1B; }
        .quiz-choice.reveal-correct { background-color: #A7F3D0; border-color: #059669; color: #047857;}
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--subtle-bg); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #bdc3c7; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #95a5a6; }

        #messageBox {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 0.75rem 1.25rem; border-radius: 8px; color: white;
            z-index: 1000; opacity: 0; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            min-width: 280px; text-align: center; box-shadow: var(--shadow-medium); font-size: 0.9rem;
        }
        #messageBox.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        #messageBox.success { background-color: #2ECC71; } 
        #messageBox.error { background-color: #E74C3C; } 
        #messageBox.info { background-color: var(--primary-red); }

        #controlPanel {
            max-height: 0; overflow: hidden; transition: max-height 0.5s ease-in-out;
            background-color: var(--bg-panel); border: 1px solid var(--border-color);
            border-radius: 12px; box-shadow: var(--shadow-soft);
        }
        #controlPanel.open { max-height: 1000px; }
        .loading-placeholder { color: #95a5a6; font-style: italic; }
        .bar-container { width: 100%; background-color: var(--border-color); border-radius: 9999px; height: 10px; overflow: hidden; }
        .bar-fill { height: 100%; border-radius: 9999px; transition: width 0.3s ease-in-out; }
        
        #controlPanel > div:not(:last-child) { margin-bottom: 1.25rem; }
        #controlPanel > p { margin-top: 0.5rem; margin-bottom: 0.75rem; color: var(--text-secondary); }
        
        .flashcard-back-content-wrapper { 
            display: flex; flex-direction: column; justify-content: center; 
            align-items: center; flex-grow: 1; width:100%; 
        }
        #flashcardFeedbackButtons {
            width: 100%; padding-top: 0.5rem; 
            flex-shrink: 0; 
        }
        header h1 { color: var(--primary-red); }
        header h1 span.chinese-header-text { /* Specific class for Chinese text in header */
            font-family: 'Noto Serif SC', 'Noto Serif TC', 'Noto Sans SC', serif;
            color: var(--accent-gold); font-weight: 500; /* Adjusted weight */
        }
        header p { color: var(--text-secondary); }
        
        footer { border-top-color: var(--border-color); }
        footer .label-text { color: var(--text-secondary); }
        footer .bar-fill#progressBar { background-color: var(--primary-red); }
        footer .bar-fill#accuracyBar { background-color: var(--accent-gold); }
        footer .version-text { color: #bdc3c7; }

        .auth-form input {
            border: 1px solid var(--border-color); padding: 0.6rem 0.8rem;
            border-radius: 6px; margin-bottom: 1rem; width: 100%;
            background-color: var(--bg-card); color: var(--text-primary);
        }
        .auth-form input::placeholder { color: #95a5a6; }
        .auth-form input:focus {
            outline: none; border-color: var(--accent-gold);
            box-shadow: 0 0 0 3px rgba(201, 168, 124, 0.2); 
        }
        .pinyin-toggle-btn-text { 
            background-color: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color); 
            border-radius: 6px; 
            padding: 0.3rem 0.6rem; 
            font-size: 0.7rem; 
            line-height: 1;
            min-width: 80px; 
            text-align: center;
        }
        .pinyin-toggle-btn-text:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }
        .pinyin-toggle-btn-text.active {
            background-color: var(--accent-gold); 
            color: white;
            border-color: var(--accent-gold);
        }
        .language-toggle-btn {
            font-size: 0.75rem; padding: 0.25rem 0.5rem;
        }
    </style>
</head>
<body class="selection:bg-[var(--primary-red)] selection:text-white">
    <div id="messageBox"></div>

    <header class="w-full max-w-5xl mx-auto px-4 mb-10 text-center">
        <div class="flex justify-between items-center mb-1 relative"> 
            <h1 class="text-4xl md:text-5xl font-bold">
                HanziFlow <span class="text-2xl chinese-header-text">汉字流</span>
            </h1>
            <div class="flex items-center">
                <button id="languageToggleBtn" class="btn btn-subtle-outline language-toggle-btn mr-2">EN / 中文</button>
                <button id="toggleControlsBtn" class="md:hidden p-2 rounded-md hover:bg-gray-100">
                    <svg class="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
            </div>
        </div>
        <p class="text-base" data-translate="headerSubtitle">Master Chinese, one card at a time.</p>
        <div id="authStatus" class="mt-3 text-sm" data-translate="authStatusDefault">Connecting...</div>
        <button id="logoutBtn" class="btn btn-subtle-outline text-xs py-1 px-3 mt-2 hidden">
            <span data-translate="logoutBtn">Logout</span>
        </button>
    </header>

    <div id="authArea" class="w-full max-w-sm mx-auto mb-10 p-8 bg-[var(--bg-panel)] rounded-xl shadow-xl border border-[var(--border-color)]">
        <div id="loginFormContainer">
            <h2 class="text-2xl font-semibold text-center mb-6 text-[var(--primary-red)]" data-translate="loginTitle">Login</h2>
            <form id="loginForm" class="auth-form">
                <input type="email" id="loginEmail" placeholder="Email" required>
                <input type="password" id="loginPassword" placeholder="Password" required>
                <button type="submit" class="btn btn-primary-theme w-full mt-2" data-translate="loginBtn">Login</button>
            </form>
            <p class="text-center text-sm mt-4"><span data-translate="dontHaveAccount">Don't have an account?</span> <button id="showSignupBtn" class="text-[var(--accent-gold)] hover:underline font-medium" data-translate="signUpLink">Sign Up</button></p>
        </div>
        <div id="signupFormContainer" class="hidden">
            <h2 class="text-2xl font-semibold text-center mb-6 text-[var(--primary-red)]" data-translate="signUpTitle">Sign Up</h2>
            <form id="signupForm" class="auth-form">
                <input type="email" id="signupEmail" placeholder="Email" required>
                <input type="password" id="signupPassword" placeholder="Password (min. 6 characters)" required>
                <button type="submit" class="btn btn-primary-theme w-full mt-2" data-translate="signUpBtn">Sign Up</button>
            </form>
            <p class="text-center text-sm mt-4"><span data-translate="alreadyHaveAccount">Already have an account?</span> <button id="showLoginBtn" class="text-[var(--accent-gold)] hover:underline font-medium" data-translate="loginLink">Login</button></p>
        </div>
        <div class="mt-6 text-center border-t border-[var(--border-color)] pt-4">
            <button id="anonymousLoginBtn" class="btn btn-secondary-theme w-full sm:w-auto" data-translate="continueAsGuest">Continue as Guest</button>
        </div>
    </div>

    <div id="appArea" class="hidden w-full max-w-5xl mx-auto flex-col md:flex-row gap-8 px-4">
        <aside id="controlPanelContainer" class="w-full md:w-1/3 lg:w-1/4">
            <div id="controlPanel" class="p-5 shadow-xl md:sticky md:top-8"> 
                <div>
                    <label class="block text-sm font-semibold mb-1.5" data-translate="deckSourceLabel">Deck Source</label>
                    <div class="btn-toggle-group flex">
                        <button id="deckWordsBtn" class="btn flex-1 btn-toggle active" data-translate="wordsBtn">Words</button>
                        <button id="deckSentencesBtn" class="btn flex-1 btn-toggle" data-translate="sentencesBtn">Sentences</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-semibold mb-1.5" data-translate="modeLabel">Mode</label>
                    <div class="btn-toggle-group flex">
                        <button id="modeFlashcardBtn" class="btn flex-1 btn-toggle active" data-translate="flashcardBtn">Flashcard</button>
                        <button id="modeQuizBtn" class="btn flex-1 btn-toggle" data-translate="quizBtn">Quiz</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-semibold mb-1.5" data-translate="charSetLabel">Character Set</label>
                    <div class="btn-toggle-group flex">
                        <button id="charSimplifiedBtn" class="btn flex-1 btn-toggle active" data-translate="simplifiedBtn">Simplified</button>
                        <button id="charTraditionalBtn" class="btn flex-1 btn-toggle" data-translate="traditionalBtn">Traditional</button>
                    </div>
                </div>
                <div id="quizTranslationToggleContainer">
                    <label class="block text-sm font-semibold mb-1.5" data-translate="quizChoicesLabel">Quiz Choices</label>
                    <div class="btn-toggle-group flex">
                        <button id="transEnBtn" class="btn flex-1 btn-toggle active" data-translate="englishBtn">English</button>
                        <button id="transThBtn" class="btn flex-1 btn-toggle" data-translate="thaiBtn">Thai</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-semibold mb-1.5" data-translate="deckViewLabel">Deck View</label>
                    <div class="btn-toggle-group flex flex-wrap"> 
                        <button id="deckAllBtn" class="btn flex-grow sm:flex-1 btn-toggle active mb-1 sm:mb-0" data-translate="allBtn">All</button>
                        <button id="deckReviewBtn" class="btn flex-grow sm:flex-1 btn-toggle mb-1 sm:mb-0" data-translate="reviewBtn">Review</button>
                        <button id="deckUnlearnedBtn" class="btn flex-grow sm:flex-1 btn-toggle" data-translate="unlearnedBtn">Unlearned</button>
                    </div>
                </div>
                 <p id="reviewDeckCount" class="text-xs text-center" data-translate="reviewCountText">Review: 0</p>
                 <p id="learnedDeckCount" class="text-xs text-center" data-translate="learnedCountText">Learned: 0</p>
                <div class="flex items-center justify-between">
                    <label for="autoAdvanceToggle" class="text-sm font-semibold" data-translate="autoAdvanceLabel">Auto-Advance</label>
                    <button id="autoAdvanceToggle" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none bg-gray-300">
                        <span class="sr-only">Auto-Advance</span>
                        <span id="autoAdvanceToggleKnob" class="inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out translate-x-1"></span>
                    </button>
                </div>
            </div>
        </aside>

        <main class="w-full md:w-2/3 lg:w-3/4 flex-1">
            <div id="flashcardMode" class="h-80 md:h-96 relative mb-4"> 
                 <button id="pinyinToggleFlashcard" class="pinyin-toggle-btn-text absolute top-3 right-3 z-20"></button>
                <div id="flashcard" class="flip-card w-full h-full">
                    <div class="flip-card-inner">
                        <div id="flashcardFront" class="flip-card-front"> 
                            <div id="flashcardChar" class="chinese-char mb-1"></div>
                            <div id="flashcardPinyin" class="pinyin-text"></div>
                        </div>
                        <div id="flashcardBack" class="flip-card-back">
                            <div class="flashcard-back-content-wrapper">
                                <div id="flashcardEn" class="translation-text mb-2 font-semibold"></div>
                                <div id="flashcardTh" class="translation-text mb-2"></div>
                                <div id="flashcardPinyinBack" class="pinyin-text mt-2"></div>
                            </div>
                            <div id="flashcardFeedbackButtons" class="w-full flex flex-col sm:flex-row sm:justify-center gap-3"> 
                                <button id="reviewAgainBtn" class="btn btn-outline-theme flex-1">
                                    <span data-translate="reviewAgainBtn">Review Again</span>
                                </button>
                                <button id="rememberBtn" class="btn btn-outline-theme flex-1" style="color: var(--accent-gold); border-color: var(--accent-gold);">
                                    <span data-translate="rememberBtn">I Remember It</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="quizMode" class="hidden bg-[var(--bg-panel)] p-6 rounded-xl shadow-xl border border-[var(--border-color)]">
                <div id="quizQuestionArea" class="text-center mb-6 relative"> 
                    <button id="pinyinToggleQuiz" class="pinyin-toggle-btn-text absolute top-0 right-0 z-10"></button>
                    <div id="quizChar" class="chinese-char-quiz mb-1"></div>
                    <div id="quizPinyin" class="pinyin-text"></div>
                </div>
                <div id="quizChoicesArea" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
                <div id="quizFeedback" class="mt-4 text-center font-semibold"></div>
            </div>

            <div id="navigationButtons" class="mt-8 flex flex-col space-y-3 sm:flex-row sm:space-y-0 sm:justify-center sm:gap-4">
                <button id="prevBtn" class="btn btn-secondary-theme w-full sm:w-auto btn-lg">
                    <span data-translate="prevBtn">Previous</span>
                </button>
                <button id="nextBtn" class="btn btn-secondary-theme w-full sm:w-auto btn-lg">
                    <span data-translate="nextBtn">Next</span>
                </button>
            </div>
        </main>
    </div>
    
    <div id="deckActionsArea" class="hidden w-full max-w-5xl mx-auto mt-10 flex-col sm:flex-row justify-center items-center gap-4 px-4">
        <button id="shuffleDeckBtn" class="btn btn-primary-theme w-full sm:w-auto btn-lg">
            <span data-translate="shuffleDeckBtn">Shuffle Deck</span>
        </button>
        <button id="resetProgressBtn" class="btn btn-danger-theme w-full sm:w-auto btn-lg">
            <span data-translate="resetProgressBtn">Reset Progress</span>
        </button>
    </div>

    <footer id="footerArea" class="hidden w-full max-w-5xl mx-auto mt-8 pt-8 border-t px-4"> 
        <div class="grid grid-cols-2 gap-x-6 gap-y-3 items-center text-sm mb-3"> 
            <div class="label-text" data-translate="progressLabel">Progress: <span id="progressText">0/0</span></div>
            <div id="accuracyDisplayContainer" class="text-right label-text" data-translate="accuracyLabel">Accuracy: <span id="accuracyText">N/A</span></div>
            <div class="bar-container">
                <div id="progressBar" class="bar-fill"></div>
            </div>
            <div class="bar-container">
                <div id="accuracyBar" class="bar-fill"></div>
            </div>
        </div>
         <p class="version-text text-xs text-center mt-6">HanziFlow v1.12 - Redesign</p>
    </footer>

    <script type="module">
        // Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut, 
            onAuthStateChanged,
            signInAnonymously, 
            signInWithCustomToken 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc,
            deleteDoc 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Firebase variables ---
        let firebaseApp;
        let auth;
        let db;
        let currentFirebaseConfig; 
        let currentAppId; 


        // --- DATA URLs ---
        const DATA_URLS = {
            words: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRtb5XXT0vCnmLWPrtrFYXp8gcLpg9AKusdIx4KiMLbmWCGhgcUCuq0J4x8fr_Tq3afGFxd3u8cAzEc/pub?gid=961444178&single=true&output=csv',
            sentences: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRtb5XXT0vCnmLWPrtrFYXp8gcLpg9AKusdIx4KiMLbmWCGhgcUCuq0J4x8fr_Tq3afGFxd3u8cAzEc/pub?gid=156031206&single=true&output=csv'
        };

        // --- UI Text Strings for Internationalization ---
        const uiStrings = {
            en: {
                headerSubtitle: "Master Chinese, one card at a time.",
                authStatusDefault: "Connecting...",
                logoutBtn: "Logout",
                loginTitle: "Login",
                loginBtn: "Login",
                dontHaveAccount: "Don't have an account?",
                signUpLink: "Sign Up",
                signUpTitle: "Sign Up",
                signUpBtn: "Sign Up",
                alreadyHaveAccount: "Already have an account?",
                loginLink: "Login",
                continueAsGuest: "Continue as Guest",
                deckSourceLabel: "Deck Source",
                wordsBtn: "Words",
                sentencesBtn: "Sentences",
                modeLabel: "Mode",
                flashcardBtn: "Flashcard",
                quizBtn: "Quiz",
                charSetLabel: "Character Set",
                simplifiedBtn: "Simplified",
                traditionalBtn: "Traditional",
                quizChoicesLabel: "Quiz Choices",
                englishBtn: "English",
                thaiBtn: "Thai",
                deckViewLabel: "Deck View",
                allBtn: "All",
                reviewBtn: "Review",
                unlearnedBtn: "Unlearned",
                reviewCountText: "Review: {count}",
                learnedCountText: "Learned: {count}",
                autoAdvanceLabel: "Auto-Advance",
                pinyinOn: "Pinyin On",
                pinyinOff: "Pinyin Off",
                reviewAgainBtn: "Review Again",
                rememberBtn: "I Remember It",
                prevBtn: "Previous",
                nextBtn: "Next",
                shuffleDeckBtn: "Shuffle Deck",
                resetProgressBtn: "Reset Progress",
                progressLabel: "Progress: {reviewed}/{total}",
                accuracyLabel: "Accuracy: {accuracy}",
                authStatusLoggedInAs: "Logged in as: {email}",
                authStatusGuest: "Logged in as: Guest (Local Progress)",
                authStatusNotLoggedIn: "Not logged in.",
                confirmResetLocal: "Are you sure you want to reset all progress for this deck source? This will clear locally stored data.",
                confirmResetAccount: "Are you sure you want to reset all progress for this deck source? This will clear data from your account for this deck."
            },
            zh: {
                headerSubtitle: "轻松学中文，一次一张卡。",
                authStatusDefault: "连接中...",
                logoutBtn: "登出",
                loginTitle: "登录",
                loginBtn: "登录",
                dontHaveAccount: "还没有账户？",
                signUpLink: "注册",
                signUpTitle: "注册",
                signUpBtn: "注册",
                alreadyHaveAccount: "已经有账户了？",
                loginLink: "登录",
                continueAsGuest: "游客模式（本地保存）",
                deckSourceLabel: "卡组来源",
                wordsBtn: "单词",
                sentencesBtn: "句子",
                modeLabel: "模式",
                flashcardBtn: "闪卡",
                quizBtn: "测验",
                charSetLabel: "字符集",
                simplifiedBtn: "简体",
                traditionalBtn: "繁体",
                quizChoicesLabel: "测验选项",
                englishBtn: "英文",
                thaiBtn: "泰文",
                deckViewLabel: "卡组视图",
                allBtn: "全部",
                reviewBtn: "复习",
                unlearnedBtn: "未学习",
                reviewCountText: "复习: {count}",
                learnedCountText: "已学习: {count}",
                autoAdvanceLabel: "自动前进",
                pinyinOn: "拼音开",
                pinyinOff: "拼音关",
                reviewAgainBtn: "再次复习",
                rememberBtn: "我记住了",
                prevBtn: "上一个",
                nextBtn: "下一个",
                shuffleDeckBtn: "打乱卡组",
                resetProgressBtn: "重置进度",
                progressLabel: "进度: {reviewed}/{total}",
                accuracyLabel: "准确率: {accuracy}",
                authStatusLoggedInAs: "登录身份: {email}",
                authStatusGuest: "登录身份: 游客 (本地保存)",
                authStatusNotLoggedIn: "未登录",
                confirmResetLocal: "您确定要重置此卡组来源的所有进度吗？这将清除本地存储的数据。",
                confirmResetAccount: "您确定要重置此卡组来源的所有进度吗？这将清除您帐户中此卡组的数据。"
            }
        };


        // --- STATE VARIABLES ---
        let appState = {
            deckSource: 'words', 
            currentMode: 'flashcard', 
            showSimplified: true, 
            showPinyin: true, 
            quizTranslationLanguage: 'en', 
            deckViewType: 'all', 
            autoAdvance: false,
            masterDeck: [], 
            currentDeck: [], 
            progress: { 
                words: { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null },
                sentences: { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null }
            },
            isFlashcardFlipped: false,
            controlPanelOpen: false,
            isLoading: false,
            currentUser: null, 
            userId: null, 
            isAnonymousUser: false,
            uiLanguage: 'en' 
        };

        const el = {}; 

        // --- UTILITY FUNCTIONS ---
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        };
        const showMessage = (text, type = 'info', duration = 3000) => {
            if (el.messageBox) { 
                el.messageBox.textContent = text;
                el.messageBox.className = ''; 
                el.messageBox.classList.add('show', type);
                setTimeout(() => {
                    el.messageBox.classList.remove('show');
                }, duration);
            } else {
                console.log(`Message (${type}): ${text}`); 
            }
        };
        
        // --- DATA FETCHING AND PARSING (from CSV) ---
        const fetchCSVData = async (url, idPrefix) => {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network response: ${response.statusText}`);
                const csvText = await response.text();
                return parseCSVToObjects(csvText, idPrefix);
            } catch (error) {
                console.error('Failed to fetch/parse CSV:', error);
                showMessage(`Error loading master deck: ${error.message}`, 'error', 5000);
                return [];
            }
        };
        const parseCSVToObjects = (csvText, idPrefix) => {
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length <= 1) return []; 
            const dataObjects = [];
            for (let i = 1; i < lines.length; i++) { 
                if (lines[i].trim() === '') continue; 
                const values = lines[i].split(','); 
                if (values.length >= 5) { 
                    dataObjects.push({
                        id: `${idPrefix}${i}`, 
                        s: values[0]?.trim()||'', t: values[1]?.trim()||'', 
                        p: values[2]?.trim()||'', en: values[3]?.trim()||'', 
                        th: values[4]?.trim()||''
                    });
                } else console.warn(`Skipping malformed CSV line ${i+1}: ${lines[i]}`);
            }
            return dataObjects;
        };
        
        // --- PROGRESS DATA HANDLING (Conditional: Firestore or LocalStorage) ---
        const getDeckState = () => appState.progress[appState.deckSource];
        const loadProgress = async () => {
            if (appState.isAnonymousUser) {
                loadProgressFromLocalStorage();
            } else if (appState.userId && db) { 
                await loadUserProgressFromFirestore();
            } else { 
                console.log("No user or DB not ready, resetting local progress state.");
                appState.progress.words = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null };
                appState.progress.sentences = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null };
            }
        };
        const saveProgress = async () => {
            if (appState.isAnonymousUser) {
                saveDeckStateToLocalStorage();
            } else if (appState.userId && db) {
                await saveDeckStateToFirestore();
            }
        };
        const resetProgress = async () => {
            const deckSourceToReset = appState.deckSource;
            if (appState.isAnonymousUser) {
                resetProgressInLocalStorage(deckSourceToReset);
            } else if (appState.userId && db) {
                await resetUserProgressInFirestore(deckSourceToReset);
            }
            appState.progress[deckSourceToReset] = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null };
            filterAndSetCurrentDeck(); 
            showMessage(`Progress for ${deckSourceToReset} deck has been reset.`, "info");
            updateDisplay();
        };

        // --- LocalStorage Specific Functions ---
        const loadProgressFromLocalStorage = () => {
            console.log("Loading progress from localStorage for anonymous user.");
            ['words', 'sentences'].forEach(source => {
                const reviewKey = `hanziflow_anon_reviewIds_${source}`;
                const learnedKey = `hanziflow_anon_learnedIds_${source}`;
                const quizAttemptsKey = `hanziflow_anon_quizAttempts_${source}`;
                const quizCorrectKey = `hanziflow_anon_quizCorrect_${source}`;
                const currentIndexKey = `hanziflow_anon_currentIndex_${source}`;

                const storedReviewIds = localStorage.getItem(reviewKey);
                const storedLearnedIds = localStorage.getItem(learnedKey);
                const storedQuizAttempts = localStorage.getItem(quizAttemptsKey);
                const storedQuizCorrect = localStorage.getItem(quizCorrectKey);
                const storedCurrentIndex = localStorage.getItem(currentIndexKey);

                appState.progress[source] = { 
                    currentIndex: storedCurrentIndex ? parseInt(storedCurrentIndex, 10) : 0,
                    quizAttempts: storedQuizAttempts ? parseInt(storedQuizAttempts, 10) : 0, 
                    quizCorrect: storedQuizCorrect ? parseInt(storedQuizCorrect, 10) : 0, 
                    reviewIds: storedReviewIds ? new Set(JSON.parse(storedReviewIds)) : new Set(), 
                    learnedIds: storedLearnedIds ? new Set(JSON.parse(storedLearnedIds)) : new Set(), 
                    quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null
                };
            });
        };
        const saveDeckStateToLocalStorage = () => {
            const deckState = getDeckState();
            const source = appState.deckSource;
            localStorage.setItem(`hanziflow_anon_reviewIds_${source}`, JSON.stringify(Array.from(deckState.reviewIds)));
            localStorage.setItem(`hanziflow_anon_learnedIds_${source}`, JSON.stringify(Array.from(deckState.learnedIds)));
            localStorage.setItem(`hanziflow_anon_quizAttempts_${source}`, deckState.quizAttempts.toString());
            localStorage.setItem(`hanziflow_anon_quizCorrect_${source}`, deckState.quizCorrect.toString());
            localStorage.setItem(`hanziflow_anon_currentIndex_${source}`, deckState.currentIndex.toString());
            console.log(`Anonymous progress for ${source} (index ${deckState.currentIndex}) saved to localStorage.`);
        };
        const resetProgressInLocalStorage = (deckSourceToReset) => {
            localStorage.removeItem(`hanziflow_anon_reviewIds_${deckSourceToReset}`);
            localStorage.removeItem(`hanziflow_anon_learnedIds_${deckSourceToReset}`);
            localStorage.removeItem(`hanziflow_anon_quizAttempts_${deckSourceToReset}`);
            localStorage.removeItem(`hanziflow_anon_quizCorrect_${deckSourceToReset}`);
            localStorage.removeItem(`hanziflow_anon_currentIndex_${deckSourceToReset}`);
            console.log(`Anonymous progress for ${deckSourceToReset} reset in localStorage.`);
        };

        // --- Firestore Specific Functions ---
        const loadUserProgressFromFirestore = async () => {
            if (!appState.userId || !db || appState.isAnonymousUser) { 
                console.log("Skipping Firestore load: No user ID, DB not init, or anonymous user.");
                return;
            }
            console.log("Loading progress from Firestore for user:", appState.userId);
            for (const source of ['words', 'sentences']) {
                const docRef = doc(db, "artifacts", currentAppId, "users", appState.userId, "progress", source);
                try {
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        appState.progress[source] = {
                            currentIndex: 0, 
                            quizAttempts: data.quizAttempts || 0, quizCorrect: data.quizCorrect || 0,
                            reviewIds: new Set(data.reviewIds || []), learnedIds: new Set(data.learnedIds || []),
                            quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null
                        };
                    } else {
                        appState.progress[source] = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null };
                    }
                } catch (error) {
                    console.error(`Error loading Firestore progress for ${source}:`, error);
                    showMessage(`Error loading your progress for ${source}.`, 'error');
                    appState.progress[source] = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false, currentQuizChoices: [], currentQuizItemId: null };
                }
            }
        };
        const saveDeckStateToFirestore = async () => {
            if (!appState.userId || !db || appState.isAnonymousUser) {
                console.warn("Skipping Firestore save: No user ID, DB not init, or anonymous user.");
                return;
            }
            const deckState = getDeckState();
            const source = appState.deckSource;
            if (!currentAppId || currentAppId.includes("YOUR_") || currentAppId.includes("MISSING_") || currentAppId.includes("INVALID_")) {
                console.error("Invalid currentAppId for Firestore path:", currentAppId, "Cannot save progress.");
                showMessage("Error: App ID for database is not configured correctly.", "error");
                return;
            }
            const docRef = doc(db, "artifacts", currentAppId, "users", appState.userId, "progress", source);
            const dataToSave = {
                quizAttempts: deckState.quizAttempts, quizCorrect: deckState.quizCorrect,
                reviewIds: Array.from(deckState.reviewIds), learnedIds: Array.from(deckState.learnedIds)
            };
            try {
                await setDoc(docRef, dataToSave, { merge: true }); 
                console.log(`Progress for ${source} saved to Firestore.`);
            } catch (error) {
                console.error(`Error saving progress for ${source}:`, error);
                showMessage(`Error saving your progress.`, 'error');
            }
        };
        const resetUserProgressInFirestore = async (deckSourceToReset) => {
            if (!appState.userId || !db || appState.isAnonymousUser) return;
            if (!currentAppId || currentAppId.includes("YOUR_") || currentAppId.includes("MISSING_") || currentAppId.includes("INVALID_")) {
                console.error("Invalid currentAppId for Firestore path:", currentAppId, "Cannot reset progress.");
                return;
            }
            const docRef = doc(db, "artifacts", currentAppId, "users", appState.userId, "progress", deckSourceToReset);
            try {
                await setDoc(docRef, {
                    quizAttempts: 0, quizCorrect: 0, reviewIds: [], learnedIds: []
                });
                console.log(`Progress for ${deckSourceToReset} reset in Firestore.`);
            } catch (error) {
                console.error(`Error resetting progress for ${deckSourceToReset}:`, error);
                showMessage(`Error resetting progress.`, 'error');
            }
        };

        // --- INITIALIZATION AND DATA LOADING ---
        const initializeDeck = async () => { 
            appState.isLoading = true;
            setLoadingState(true);
            
            const url = DATA_URLS[appState.deckSource];
            const idPrefix = appState.deckSource === 'words' ? 'w' : 's';
            
            appState.masterDeck = await fetchCSVData(url, idPrefix);
            shuffleArray(appState.masterDeck); 
            
            appState.isLoading = false;
            setLoadingState(false);

            if (appState.masterDeck.length === 0 && url) { 
                 showMessage(`No items found in ${appState.deckSource} deck. Check data source.`, 'error', 5000);
            }
            
            const currentDeckState = getDeckState();
            // currentIndex is loaded from storage, don't reset to 0 here.
            currentDeckState.quizAnsweredCurrent = false; 
            currentDeckState.currentQuizChoices = []; 
            currentDeckState.currentQuizItemId = null;
            
            filterAndSetCurrentDeck(); 
            if (currentDeckState.currentIndex >= appState.currentDeck.length && appState.currentDeck.length > 0) {
                currentDeckState.currentIndex = appState.currentDeck.length - 1;
            } else if (appState.currentDeck.length === 0) {
                currentDeckState.currentIndex = 0;
            }
            updateDisplay();
        };
        
        // --- UI State Updates ---
        const setLoadingState = (isLoading) => {
            appState.isLoading = isLoading;
            const loadingText = "Loading...";
            if (!el.flashcardChar || !el.quizChar) return; 

            if (isLoading) {
                if (appState.currentMode === 'flashcard') {
                    el.flashcardChar.textContent = loadingText; el.flashcardChar.classList.add('loading-placeholder');
                    el.flashcardPinyin.textContent = ''; el.flashcardEn.textContent = ''; el.flashcardTh.textContent = '';
                } else {
                    el.quizChar.textContent = loadingText; el.quizChar.classList.add('loading-placeholder');
                    el.quizPinyin.textContent = ''; el.quizChoicesArea.innerHTML = '';
                }
                 document.querySelectorAll('#appArea button, #deckActionsArea button, #controlPanel button').forEach(btn => btn.disabled = true);
                 if(el.pinyinToggleFlashcard) el.pinyinToggleFlashcard.disabled = true;
                 if(el.pinyinToggleQuiz) el.pinyinToggleQuiz.disabled = true;
                 if(el.languageToggleBtn) el.languageToggleBtn.disabled = true;
            } else {
                el.flashcardChar.classList.remove('loading-placeholder'); el.quizChar.classList.remove('loading-placeholder');
                document.querySelectorAll('#appArea button, #deckActionsArea button, #controlPanel button').forEach(btn => btn.disabled = false);
                if(el.shuffleDeckBtn) el.shuffleDeckBtn.disabled = appState.currentDeck.length === 0;
                if(el.pinyinToggleFlashcard) el.pinyinToggleFlashcard.disabled = false;
                if(el.pinyinToggleQuiz) el.pinyinToggleQuiz.disabled = false;
                if(el.languageToggleBtn) el.languageToggleBtn.disabled = false;
            }
            if(el.flashcardChar) updateDisplay(); 
        };
        const filterAndSetCurrentDeck = () => {
            const deckState = getDeckState(); let deckToUse = [];
            if (appState.deckViewType === 'all') deckToUse = [...appState.masterDeck];
            else if (appState.deckViewType === 'review') {
                deckToUse = appState.masterDeck.filter(item => deckState.reviewIds.has(item.id)); shuffleArray(deckToUse);
            } else if (appState.deckViewType === 'unlearned') {
                deckToUse = appState.masterDeck.filter(item => !deckState.learnedIds.has(item.id)); shuffleArray(deckToUse);
            }
            appState.currentDeck = deckToUse;
            if(el.shuffleDeckBtn) el.shuffleDeckBtn.disabled = appState.isLoading || appState.currentDeck.length === 0;
            if (deckState.currentIndex >= appState.currentDeck.length) deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
             if (appState.currentDeck.length === 0) deckState.currentIndex = 0; 
            if (appState.currentDeck.length === 0 && appState.masterDeck.length > 0) {
                showMessage(`${appState.deckViewType.charAt(0).toUpperCase() + appState.deckViewType.slice(1)} deck is empty.`, "info");
            }
        };
        const updateFlashcardAnimation = () => {
            if (el.flashcardInner) { // Check if the element exists
                if (appState.autoAdvance && appState.currentMode === 'flashcard') { // Only disable for flashcard auto-advance
                    el.flashcardInner.style.transition = 'none';
                } else {
                    el.flashcardInner.style.transition = 'transform 0.5s';
                }
            }
        };
        const updateDisplay = () => {
            if (!el.deckWordsBtn) return; 
            updateUILanguage(); 
            updateToggleButtonStates(); 
            updatePinyinToggleButtonsState(); 
            updateModeVisibility(); 
            updateNavigationButtons();
            updateProgressAndAccuracy(); 
            updateStatusCounts();
            updateFlashcardAnimation(); 
            if (appState.isLoading) {
                if(el.prevBtn) el.prevBtn.disabled = true; if(el.nextBtn) el.nextBtn.disabled = true;
                if(el.quizChoicesArea) el.quizChoicesArea.innerHTML = ''; return;
            }
            const deckState = getDeckState();
            if (appState.currentDeck.length === 0) {
                const msg = `${appState.deckViewType.charAt(0).toUpperCase() + appState.deckViewType.slice(1)} Deck Empty`;
                if (appState.currentMode === 'flashcard') {
                    el.flashcardChar.textContent = msg; el.flashcardPinyin.textContent = ''; el.flashcardEn.textContent = '';
                    el.flashcardTh.textContent = ''; el.flashcardPinyinBack.textContent = '';
                    el.flashcard.classList.remove('flipped'); appState.isFlashcardFlipped = false;
                } else {
                    el.quizChar.textContent = msg; el.quizPinyin.textContent = '';
                    el.quizChoicesArea.innerHTML = ''; el.quizFeedback.textContent = '';
                }
                if(el.prevBtn) el.prevBtn.disabled = true; if(el.nextBtn) el.nextBtn.disabled = true; return;
            }
            if (deckState.currentIndex >= appState.currentDeck.length) deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
            if (deckState.currentIndex < 0 && appState.currentDeck.length > 0) deckState.currentIndex = 0;
            const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) {
                el.flashcardChar.textContent = 'Error.'; if(el.prevBtn) el.prevBtn.disabled = true; if(el.nextBtn) el.nextBtn.disabled = true; return;
            }
            const charToDisplay = appState.showSimplified ? currentItem.s : currentItem.t;
            const pinyinToDisplay = appState.showPinyin ? currentItem.p : '';
            if (appState.currentMode === 'flashcard') {
                el.flashcardChar.textContent = charToDisplay; el.flashcardPinyin.textContent = pinyinToDisplay;
                el.flashcardEn.textContent = currentItem.en; el.flashcardTh.textContent = currentItem.th;
                el.flashcardPinyinBack.textContent = pinyinToDisplay;
                el.flashcard.classList.toggle('flipped', appState.isFlashcardFlipped);
            } else { // Quiz Mode
                el.quizChar.textContent = charToDisplay; el.quizPinyin.textContent = pinyinToDisplay;
                if (!deckState.quizAnsweredCurrent && 
                    (deckState.currentQuizItemId !== currentItem.id || deckState.currentQuizChoices.length === 0)) {
                    renderQuizChoices(currentItem); 
                } else if (!deckState.quizAnsweredCurrent && 
                           deckState.currentQuizItemId === currentItem.id && 
                           deckState.currentQuizChoices.length > 0) {
                    renderQuizChoices(currentItem, true); 
                }
                 if (!deckState.quizAnsweredCurrent) el.quizFeedback.textContent = '';
            }
        };
        const updateToggleButtonStates = () => { 
            el.deckWordsBtn.classList.toggle('active', appState.deckSource === 'words');
            el.deckSentencesBtn.classList.toggle('active', appState.deckSource === 'sentences');
            el.modeFlashcardBtn.classList.toggle('active', appState.currentMode === 'flashcard');
            el.modeQuizBtn.classList.toggle('active', appState.currentMode === 'quiz');
            el.charSimplifiedBtn.classList.toggle('active', appState.showSimplified);
            el.charTraditionalBtn.classList.toggle('active', !appState.showSimplified);
            el.transEnBtn.classList.toggle('active', appState.quizTranslationLanguage === 'en');
            el.transThBtn.classList.toggle('active', appState.quizTranslationLanguage === 'th');
            el.deckAllBtn.classList.toggle('active', appState.deckViewType === 'all');
            el.deckReviewBtn.classList.toggle('active', appState.deckViewType === 'review');
            el.deckUnlearnedBtn.classList.toggle('active', appState.deckViewType === 'unlearned');
            el.autoAdvanceToggle.classList.toggle('bg-[var(--primary-red)]', appState.autoAdvance);
            el.autoAdvanceToggle.classList.toggle('bg-gray-200', !appState.autoAdvance);
            el.autoAdvanceToggleKnob.classList.toggle('translate-x-5', appState.autoAdvance);
            el.autoAdvanceToggleKnob.classList.toggle('translate-x-1', !appState.autoAdvance);
        };
        const updatePinyinToggleButtonsState = () => {
            const isActive = appState.showPinyin;
            const lang = appState.uiLanguage;
            const text = isActive ? uiStrings[lang].pinyinOn : uiStrings[lang].pinyinOff;
            
            if(el.pinyinToggleFlashcard) {
                el.pinyinToggleFlashcard.classList.toggle('active', isActive);
                el.pinyinToggleFlashcard.textContent = text;
            }
            if(el.pinyinToggleQuiz) {
                el.pinyinToggleQuiz.classList.toggle('active', isActive);
                el.pinyinToggleQuiz.textContent = text;
            }
        };
        const updateModeVisibility = () => { 
            const isFlashcard = appState.currentMode === 'flashcard';
            el.flashcardModeDiv.classList.toggle('hidden', !isFlashcard);
            el.quizModeDiv.classList.toggle('hidden', isFlashcard);
            el.quizTranslationToggleContainer.classList.toggle('hidden', isFlashcard); 
            el.accuracyDisplayContainer.classList.toggle('hidden', isFlashcard); 
            if (!appState.isLoading && appState.currentMode === 'quiz') { 
                 const deckState = getDeckState();
            }
        };
        const updateNavigationButtons = () => { 
            el.navigationButtons.classList.toggle('hidden', appState.autoAdvance || appState.isLoading);
            const deckState = getDeckState();
            if (appState.currentDeck.length === 0 || appState.isLoading) {
                el.prevBtn.disabled = true; el.nextBtn.disabled = true;
            } else {
                el.prevBtn.disabled = deckState.currentIndex === 0;
                el.nextBtn.disabled = deckState.currentIndex === appState.currentDeck.length - 1;
            }
        };
        const updateProgressAndAccuracy = () => { 
            const deckState = getDeckState();
            const totalItems = appState.currentDeck.length;
            const reviewedItems = totalItems > 0 ? deckState.currentIndex + 1 : 0;
            
            const progressTextKey = uiStrings[appState.uiLanguage].progressLabel || "Progress: {reviewed}/{total}";
            el.progressText.innerHTML = progressTextKey.replace("{reviewed}", reviewedItems).replace("{total}", totalItems);
            
            el.progressBar.style.width = totalItems > 0 ? `${(reviewedItems / totalItems) * 100}%` : '0%';
            if (appState.currentMode === 'quiz') {
                const accuracy = deckState.quizAttempts > 0 ? ((deckState.quizCorrect / deckState.quizAttempts) * 100) : 0; 
                const accuracyTextKey = uiStrings[appState.uiLanguage].accuracyLabel || "Accuracy: {accuracy}";
                el.accuracyText.innerHTML = accuracyTextKey.replace("{accuracy}", deckState.quizAttempts > 0 ? `${accuracy.toFixed(0)}%` : 'N/A');
                el.accuracyBar.style.width = `${accuracy}%`;
            } else {
                 el.accuracyText.innerHTML = uiStrings[appState.uiLanguage].accuracyLabel.replace("{accuracy}", "N/A");
                 el.accuracyBar.style.width = '0%';
            }
        };
        const updateStatusCounts = () => { 
            const deckState = getDeckState();
            const reviewTextKey = uiStrings[appState.uiLanguage].reviewCountText || "Review: {count}";
            const learnedTextKey = uiStrings[appState.uiLanguage].learnedCountText || "Learned: {count}";
            el.reviewDeckCount.textContent = reviewTextKey.replace("{count}", deckState.reviewIds.size);
            el.learnedDeckCount.textContent = learnedTextKey.replace("{count}", deckState.learnedIds.size);
        };

        // --- CORE LOGIC ---
        const flipCard = () => { 
            if (appState.isLoading || appState.currentDeck.length === 0) return;
            appState.isFlashcardFlipped = !appState.isFlashcardFlipped;
            el.flashcard.classList.toggle('flipped', appState.isFlashcardFlipped);
        };
        const handleFlashcardFeedback = (isRemembered) => { 
            if (appState.isLoading) return; 
            if (!appState.isAnonymousUser && !appState.currentUser) {
                showMessage("Please log in to save progress.", "info"); return;
            }
            const deckState = getDeckState(); const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) return; 
            const charText = appState.showSimplified ? currentItem.s : currentItem.t;
            if (isRemembered) {
                showMessage(`"${charText}" marked as remembered.`, 'success', 1500);
                deckState.learnedIds.add(currentItem.id); deckState.reviewIds.delete(currentItem.id); 
            } else { 
                showMessage(`"${charText}" added to review.`, 'info', 1500);
                deckState.reviewIds.add(currentItem.id); deckState.learnedIds.delete(currentItem.id); 
            }
            saveProgress(); 
            updateStatusCounts(); 
            let deckNeedsRefilter = false;
            if (appState.deckViewType === 'unlearned' && isRemembered) deckNeedsRefilter = true;
            else if (appState.deckViewType === 'review' && isRemembered) deckNeedsRefilter = true;
            if (appState.autoAdvance) {
                const delay = 1000; // Standard 1 second delay
                setTimeout(() => {
                    if (deckNeedsRefilter) { 
                        const oldIndex = deckState.currentIndex; 
                        filterAndSetCurrentDeck(); 
                        if (appState.currentDeck.length > 0) {
                            deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                            if (deckState.currentIndex < appState.currentDeck.length -1 || (appState.currentDeck.length === 1 && deckState.currentIndex === 0) ) {
                                if (!(appState.currentDeck.length > 0 && oldIndex === appState.currentDeck.length && isRemembered && appState.deckViewType !== 'all')) {
                                   goToNextItem();
                                } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                            } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                        } else { updateDisplay(); }
                    } else {
                        goToNextItem();
                    }
                }, delay); 
            } else if (deckNeedsRefilter) { 
                const oldIndex = deckState.currentIndex; filterAndSetCurrentDeck();
                if (appState.currentDeck.length > 0) { 
                    deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                }
                updateDisplay(); 
            }
        };
        const renderQuizChoices = (currentItem, reuseStoredChoices = false) => { 
            const deckState = getDeckState(); 
            console.log("[renderQuizChoices] Called. quizAnsweredCurrent:", deckState.quizAnsweredCurrent, "reuseStored:", reuseStoredChoices, "storedChoices:", deckState.currentQuizChoices);
            el.quizChoicesArea.innerHTML = ''; 
            
            let choices;
            if (reuseStoredChoices && deckState.currentQuizItemId === currentItem.id && deckState.currentQuizChoices.length > 0) {
                choices = [...deckState.currentQuizChoices];
                console.log("[renderQuizChoices] Reusing stored choices for item", currentItem.id, ":", choices);
            } else {
                const correctAnswerLang = appState.quizTranslationLanguage === 'en' ? currentItem.en : currentItem.th;
                choices = [correctAnswerLang];
                const distractors = appState.masterDeck.filter(item => item.id !== currentItem.id)
                    .map(item => appState.quizTranslationLanguage === 'en' ? item.en : item.th)
                    .filter((value, index, self) => value && self.indexOf(value) === index && value !== correctAnswerLang); 
                shuffleArray(distractors);
                choices = choices.concat(distractors.slice(0, Math.min(3, distractors.length))); 
                shuffleArray(choices); 
                deckState.currentQuizChoices = [...choices]; 
                deckState.currentQuizItemId = currentItem.id; 
                console.log("[renderQuizChoices] Generated and stored new choices for item", currentItem.id, ":", choices);
            }

            choices.forEach(choiceText => {
                const choiceButton = document.createElement('button');
                choiceButton.className = 'btn btn-theme-outline w-full text-left p-3 quiz-choice';
                choiceButton.textContent = choiceText;
                choiceButton.onclick = () => handleQuizAnswer(choiceText === (appState.quizTranslationLanguage === 'en' ? currentItem.en : currentItem.th), choiceButton, (appState.quizTranslationLanguage === 'en' ? currentItem.en : currentItem.th));
                el.quizChoicesArea.appendChild(choiceButton);
            });
        };
        const handleQuizAnswer = (isCorrect, clickedButton, correctAnswerText) => { 
            console.log("[handleQuizAnswer] Called. isCorrect:", isCorrect, "Button text:", clickedButton.textContent);
            const deckState = getDeckState();
            
            if (appState.isLoading) { console.log("[handleQuizAnswer] Exiting: isLoading"); return; }
            if (!appState.isAnonymousUser && !appState.currentUser) { 
                showMessage("Please log in to save quiz progress.", "info");
                return; 
            }
            if (deckState.quizAnsweredCurrent) { console.log("[handleQuizAnswer] Exiting: quizAnsweredCurrent"); return; }
            console.log("[handleQuizAnswer] Proceeding.");

            deckState.quizAnsweredCurrent = true; 
            deckState.quizAttempts++;
            const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) { console.error("[handleQuizAnswer] Error: currentItem is undefined."); return; }
            const charText = appState.showSimplified ? currentItem.s : currentItem.t;
            let deckNeedsRefilter = false;
            if (isCorrect) {
                deckState.quizCorrect++;
                el.quizFeedback.textContent = 'Correct! 🎉'; el.quizFeedback.className = 'mt-4 text-center font-semibold text-green-600';
                clickedButton.className = 'btn w-full text-left p-3 quiz-choice correct';
                showMessage('Correct!', 'success', 1500);
                deckState.learnedIds.add(currentItem.id); deckState.reviewIds.delete(currentItem.id);
                if (appState.deckViewType === 'unlearned') deckNeedsRefilter = true;
            } else { 
                el.quizFeedback.innerHTML = `Incorrect. Correct: <span class="font-bold">${correctAnswerText}</span>`;
                el.quizFeedback.className = 'mt-4 text-center font-semibold text-red-600';
                clickedButton.className = 'btn w-full text-left p-3 quiz-choice incorrect';
                Array.from(el.quizChoicesArea.children).forEach(btn => {
                    if (btn.textContent === correctAnswerText) btn.className = 'btn w-full text-left p-3 quiz-choice reveal-correct';
                    btn.disabled = true; 
                });
                deckState.reviewIds.add(currentItem.id); deckState.learnedIds.delete(currentItem.id); 
                showMessage(`Added "${charText}" to review.`, 'error', 2000);
            }
            saveProgress(); 
            updateStatusCounts(); updateProgressAndAccuracy(); 
            if (appState.autoAdvance) {
                 const delay = isCorrect ? 1600 : 2600; 
                 if (deckNeedsRefilter) {
                    setTimeout(() => {
                        const oldIndex = deckState.currentIndex; filterAndSetCurrentDeck();
                        if (appState.currentDeck.length > 0) {
                            deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                            if (deckState.currentIndex < appState.currentDeck.length -1 || (appState.currentDeck.length === 1 && deckState.currentIndex === 0) || (!isCorrect && deckState.currentIndex <= appState.currentDeck.length -1) ) {
                                 if (!(appState.currentDeck.length > 0 && oldIndex === appState.currentDeck.length && isCorrect && appState.deckViewType !== 'all')) {
                                   goToNextItem();
                                } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                            } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                        } else { updateDisplay(); }
                    }, delay); 
                } else { setTimeout(goToNextItem, delay); }
            } else if (deckNeedsRefilter) { 
                 const oldIndex = deckState.currentIndex; filterAndSetCurrentDeck();
                 if (appState.currentDeck.length > 0) { 
                    deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                }
                 updateDisplay(); 
            }
        };
        const goToNextItem = () => { 
            if (appState.isLoading) return;
            const deckState = getDeckState();
            if (deckState.currentIndex < appState.currentDeck.length - 1) {
                deckState.currentIndex++; 
            } else if (appState.currentDeck.length > 0) { 
                showMessage("You've reached the end of the deck!", "info"); return; 
            } else { return; } 
            appState.isFlashcardFlipped = false; 
            deckState.quizAnsweredCurrent = false; 
            deckState.currentQuizChoices = []; 
            deckState.currentQuizItemId = null;
            updateDisplay();
        };
        const goToPrevItem = () => { 
            if (appState.isLoading) return;
            const deckState = getDeckState();
            if (deckState.currentIndex > 0) {
                deckState.currentIndex--;
                appState.isFlashcardFlipped = false;
                deckState.quizAnsweredCurrent = false;
                deckState.currentQuizChoices = []; 
                deckState.currentQuizItemId = null;
                updateDisplay();
            }
        };
        
        // --- DOM Element Setup ---
        const setupDOMReferences = () => { 
            el.authArea = document.getElementById('authArea');
            el.appArea = document.getElementById('appArea');
            el.deckActionsArea = document.getElementById('deckActionsArea');
            el.footerArea = document.getElementById('footerArea');
            el.loginForm = document.getElementById('loginForm');
            el.signupForm = document.getElementById('signupForm');
            el.loginEmail = document.getElementById('loginEmail');
            el.loginPassword = document.getElementById('loginPassword');
            el.signupEmail = document.getElementById('signupEmail');
            el.signupPassword = document.getElementById('signupPassword');
            el.showSignupBtn = document.getElementById('showSignupBtn');
            el.showLoginBtn = document.getElementById('showLoginBtn');
            el.logoutBtn = document.getElementById('logoutBtn');
            el.authStatus = document.getElementById('authStatus');
            el.loginFormContainer = document.getElementById('loginFormContainer');
            el.signupFormContainer = document.getElementById('signupFormContainer');
            el.anonymousLoginBtn = document.getElementById('anonymousLoginBtn'); 
            el.languageToggleBtn = document.getElementById('languageToggleBtn'); 
            el.deckWordsBtn = document.getElementById('deckWordsBtn');
            el.deckSentencesBtn = document.getElementById('deckSentencesBtn');
            el.modeFlashcardBtn = document.getElementById('modeFlashcardBtn');
            el.modeQuizBtn = document.getElementById('modeQuizBtn');
            el.charSimplifiedBtn = document.getElementById('charSimplifiedBtn');
            el.charTraditionalBtn = document.getElementById('charTraditionalBtn');
            el.pinyinToggleFlashcard = document.getElementById('pinyinToggleFlashcard');
            el.pinyinToggleQuiz = document.getElementById('pinyinToggleQuiz');
            el.quizTranslationToggleContainer = document.getElementById('quizTranslationToggleContainer');
            el.transEnBtn = document.getElementById('transEnBtn');
            el.transThBtn = document.getElementById('transThBtn');
            el.deckAllBtn = document.getElementById('deckAllBtn');
            el.deckReviewBtn = document.getElementById('deckReviewBtn');
            el.deckUnlearnedBtn = document.getElementById('deckUnlearnedBtn');
            el.reviewDeckCount = document.getElementById('reviewDeckCount');
            el.learnedDeckCount = document.getElementById('learnedDeckCount');
            el.autoAdvanceToggle = document.getElementById('autoAdvanceToggle');
            el.autoAdvanceToggleKnob = document.getElementById('autoAdvanceToggleKnob');
            el.shuffleDeckBtn = document.getElementById('shuffleDeckBtn');
            el.resetProgressBtn = document.getElementById('resetProgressBtn');
            el.flashcardModeDiv = document.getElementById('flashcardMode');
            el.quizModeDiv = document.getElementById('quizMode');
            el.flashcard = document.getElementById('flashcard');
            el.flashcardInner = document.querySelector('#flashcard .flip-card-inner'); 
            el.flashcardFront = document.getElementById('flashcardFront');
            el.flashcardChar = document.getElementById('flashcardChar');
            el.flashcardPinyin = document.getElementById('flashcardPinyin');
            el.flashcardBack = document.getElementById('flashcardBack');
            el.flashcardEn = document.getElementById('flashcardEn');
            el.flashcardTh = document.getElementById('flashcardTh');
            el.flashcardPinyinBack = document.getElementById('flashcardPinyinBack');
            el.flashcardFeedbackButtons = document.getElementById('flashcardFeedbackButtons'); 
            el.reviewAgainBtn = document.getElementById('reviewAgainBtn');
            el.rememberBtn = document.getElementById('rememberBtn');
            el.quizQuestionArea = document.getElementById('quizQuestionArea');
            el.quizChar = document.getElementById('quizChar');
            el.quizPinyin = document.getElementById('quizPinyin');
            el.quizChoicesArea = document.getElementById('quizChoicesArea');
            el.quizFeedback = document.getElementById('quizFeedback');
            el.navigationButtons = document.getElementById('navigationButtons');
            el.prevBtn = document.getElementById('prevBtn');
            el.nextBtn = document.getElementById('nextBtn');
            el.progressText = document.getElementById('progressText');
            el.progressBar = document.getElementById('progressBar');
            el.accuracyDisplayContainer = document.getElementById('accuracyDisplayContainer');
            el.accuracyText = document.getElementById('accuracyText');
            el.accuracyBar = document.getElementById('accuracyBar');
            el.messageBox = document.getElementById('messageBox');
            el.toggleControlsBtn = document.getElementById('toggleControlsBtn');
            el.controlPanel = document.getElementById('controlPanel'); 
        };
        // --- AUTHENTICATION EVENT LISTENERS AND FUNCTIONS ---
        const setupAuthEventListeners = () => { 
             if (el.loginForm) {
                el.loginForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    console.log("Login form submitted.");
                    if (!auth) { showMessage("Firebase Auth not initialized.", "error"); return; }
                    try {
                        await signInWithEmailAndPassword(auth, el.loginEmail.value, el.loginPassword.value);
                        showMessage('Logged in successfully!', 'success');
                    } catch (error) {
                        showMessage(`Login failed: ${error.message}`, 'error');
                        console.error("Login error:", error);
                    }
                });
            } else { console.error("Login form not found");}

            if (el.signupForm) {
                el.signupForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    console.log("Signup form submitted.");
                    if (!auth) { showMessage("Firebase Auth not initialized.", "error"); return; }
                    try {
                        await createUserWithEmailAndPassword(auth, el.signupEmail.value, el.signupPassword.value);
                        showMessage('Signed up successfully! You are now logged in.', 'success');
                    } catch (error) {
                        if (error.code === 'auth/operation-not-allowed') {
                            showMessage('Signup failed: Email/Password sign-in is not enabled for this app. Please check Firebase console settings.', 'error', 7000);
                            console.error("Signup error: auth/operation-not-allowed. This usually means Email/Password sign-in provider needs to be enabled in your Firebase project's Authentication settings.", error);
                        } else if (error.code === 'auth/email-already-in-use') {
                             showMessage('Signup failed: This email is already in use. Please try logging in.', 'error', 6000);
                        } else {
                            showMessage(`Signup failed: ${error.message}`, 'error');
                            console.error("Signup error:", error);
                        }
                    }
                });
            } else { console.error("Signup form not found");}

            if (el.logoutBtn) {
                el.logoutBtn.addEventListener('click', async () => {
                    console.log("Logout button clicked.");
                    if (!auth) { showMessage("Firebase Auth not initialized.", "error"); return; }
                    try {
                        await signOut(auth);
                        showMessage('Logged out.', 'info');
                    } catch (error) {
                        showMessage(`Logout failed: ${error.message}`, 'error');
                    }
                });
            } else { console.error("Logout button not found"); }

            if (el.showSignupBtn) el.showSignupBtn.addEventListener('click', () => {
                el.loginFormContainer.classList.add('hidden');
                el.signupFormContainer.classList.remove('hidden');
            });
            if (el.showLoginBtn) el.showLoginBtn.addEventListener('click', () => {
                el.signupFormContainer.classList.add('hidden');
                el.loginFormContainer.classList.remove('hidden');
            });
            if (el.anonymousLoginBtn) el.anonymousLoginBtn.addEventListener('click', async () => {
                console.log("Anonymous login button clicked.");
                if (!auth) { showMessage("Firebase Auth not initialized.", "error"); return; }
                try {
                    await signInAnonymously(auth);
                    showMessage('Continuing as Guest. Progress will be saved locally.', 'info');
                } catch (error) {
                    showMessage(`Anonymous login failed: ${error.message}`, 'error');
                    console.error("Anonymous login error:", error);
                }
            });
        };
        const updateUIForAuthState = (user) => { 
            if (user) {
                el.authArea.classList.add('hidden');
                el.appArea.style.display = 'flex'; 
                el.deckActionsArea.style.display = 'flex';
                el.footerArea.style.display = 'block'; 
                el.authStatus.textContent = user.isAnonymous ? uiStrings[appState.uiLanguage].authStatusGuest : uiStrings[appState.uiLanguage].authStatusLoggedInAs.replace("{email}", user.email);
                el.logoutBtn.classList.remove('hidden');
            } else {
                el.authArea.classList.remove('hidden');
                el.appArea.style.display = 'none';
                el.deckActionsArea.style.display = 'none'; 
                el.footerArea.style.display = 'none';
                el.authStatus.textContent = uiStrings[appState.uiLanguage].authStatusNotLoggedIn;
                el.logoutBtn.classList.add('hidden');
                if(el.progressText) el.progressText.textContent = '0/0';
                if(el.progressBar) el.progressBar.style.width = '0%';
                if(el.accuracyText) el.accuracyText.textContent = 'N/A';
                if(el.accuracyBar) el.accuracyBar.style.width = '0%';
                if(el.reviewDeckCount) el.reviewDeckCount.textContent = uiStrings[appState.uiLanguage].reviewCountText.replace("{count}", 0);
                if(el.learnedDeckCount) el.learnedDeckCount.textContent = uiStrings[appState.uiLanguage].learnedCountText.replace("{count}", 0);
            }
        };
        // --- APP EVENT LISTENERS ---
        const setupAppEventListeners = () => { 
            el.languageToggleBtn.addEventListener('click', () => {
                appState.uiLanguage = appState.uiLanguage === 'en' ? 'zh' : 'en';
                updateDisplay(); 
            });
            el.deckWordsBtn.addEventListener('click', async () => {
                if (appState.isLoading || appState.deckSource === 'words') return;
                appState.deckSource = 'words';
                getDeckState().currentQuizChoices = []; getDeckState().currentQuizItemId = null; 
                await initializeDeck(); 
            });
            el.deckSentencesBtn.addEventListener('click', async () => {
                if (appState.isLoading || appState.deckSource === 'sentences') return;
                appState.deckSource = 'sentences';
                getDeckState().currentQuizChoices = []; getDeckState().currentQuizItemId = null; 
                await initializeDeck(); 
            });
            el.modeFlashcardBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.currentMode = 'flashcard'; appState.isFlashcardFlipped = false; updateDisplay();} });
            el.modeQuizBtn.addEventListener('click', () => { 
                if (!appState.isLoading) {
                    appState.currentMode = 'quiz';
                    const deckState = getDeckState();
                    deckState.quizAnsweredCurrent = false; 
                    deckState.currentQuizChoices = []; 
                    deckState.currentQuizItemId = null;
                    updateDisplay();
                }
            });
            el.charSimplifiedBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showSimplified = true; updateDisplay();} });
            el.charTraditionalBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showSimplified = false; updateDisplay();} });
            function handlePinyinToggle() {
                if (appState.isLoading) return;
                appState.showPinyin = !appState.showPinyin;
                updatePinyinToggleButtonsState(); updateDisplay(); 
            }
            el.pinyinToggleFlashcard.addEventListener('click', handlePinyinToggle);
            el.pinyinToggleQuiz.addEventListener('click', handlePinyinToggle);
            el.transEnBtn.addEventListener('click', () => { 
                if (!appState.isLoading) {
                    appState.quizTranslationLanguage = 'en'; 
                    const deckState = getDeckState();
                    deckState.currentQuizChoices = []; deckState.currentQuizItemId = null; 
                    deckState.quizAnsweredCurrent = false; 
                    updateDisplay(); 
                }
            });
            el.transThBtn.addEventListener('click', () => { 
                if (!appState.isLoading) {
                    appState.quizTranslationLanguage = 'th'; 
                    const deckState = getDeckState();
                    deckState.currentQuizChoices = []; deckState.currentQuizItemId = null; 
                    deckState.quizAnsweredCurrent = false; 
                    updateDisplay(); 
                }
            });
            el.deckAllBtn.addEventListener('click', () => { if (!appState.isLoading && appState.deckViewType !== 'all') {appState.deckViewType = 'all'; getDeckState().currentIndex = 0; getDeckState().currentQuizChoices = []; getDeckState().currentQuizItemId = null; filterAndSetCurrentDeck(); updateDisplay();}});
            el.deckReviewBtn.addEventListener('click', () => { if (!appState.isLoading && appState.deckViewType !== 'review') {appState.deckViewType = 'review'; getDeckState().currentIndex = 0; getDeckState().currentQuizChoices = []; getDeckState().currentQuizItemId = null; filterAndSetCurrentDeck(); updateDisplay();}});
            el.deckUnlearnedBtn.addEventListener('click', () => { if (!appState.isLoading && appState.deckViewType !== 'unlearned') {appState.deckViewType = 'unlearned'; getDeckState().currentIndex = 0; getDeckState().currentQuizChoices = []; getDeckState().currentQuizItemId = null; filterAndSetCurrentDeck(); updateDisplay();}});
            el.autoAdvanceToggle.addEventListener('click', () => { if (!appState.isLoading) {appState.autoAdvance = !appState.autoAdvance; updateFlashcardAnimation(); updateDisplay();}}); 
            el.shuffleDeckBtn.addEventListener('click', () => {
                if (appState.isLoading || appState.currentDeck.length === 0) return;
                shuffleArray(appState.currentDeck); 
                const deckState = getDeckState();
                deckState.currentIndex = 0; appState.isFlashcardFlipped = false; 
                deckState.quizAnsweredCurrent = false; deckState.currentQuizChoices = []; 
                deckState.currentQuizItemId = null;
                showMessage("Current deck view shuffled!", "success", 1500); updateDisplay();
            });
            el.resetProgressBtn.addEventListener('click', async () => {
                if (appState.isLoading) return;
                const currentLang = appState.uiLanguage;
                const confirmMessage = appState.isAnonymousUser ? 
                    (uiStrings[currentLang].confirmResetLocal || "Are you sure you want to reset all progress for this deck source? This will clear locally stored data.") :
                    (uiStrings[currentLang].confirmResetAccount || "Are you sure you want to reset all progress for this deck source? This will clear data from your account for this deck.");
                const userConfirmed = window.confirm(confirmMessage);
                if (!userConfirmed) return;
                await resetProgress(); 
            });
            el.flashcard.addEventListener('click', (e) => { 
                if (appState.isLoading) return;
                if (e.target.closest('#reviewAgainBtn') || e.target.closest('#rememberBtn') || e.target.closest('#pinyinToggleFlashcard')) return; 
                if (appState.currentMode === 'flashcard' && appState.currentDeck.length > 0) flipCard();
            });
            el.reviewAgainBtn.addEventListener('click', () => handleFlashcardFeedback(false));
            el.rememberBtn.addEventListener('click', () => handleFlashcardFeedback(true));
            el.prevBtn.addEventListener('click', goToPrevItem);
            el.nextBtn.addEventListener('click', goToNextItem);
            document.addEventListener('keydown', (e) => { 
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || appState.isLoading) return; 
                if (appState.autoAdvance && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ')) return; 
                if (e.key === 'ArrowLeft') goToPrevItem();
                else if (e.key === 'ArrowRight') goToNextItem();
                else if (e.key === ' ' && appState.currentMode === 'flashcard') { e.preventDefault(); flipCard(); }
            });
            el.toggleControlsBtn.addEventListener('click', () => { appState.controlPanelOpen = !appState.controlPanelOpen; el.controlPanel.classList.toggle('open', appState.controlPanelOpen);});
            function checkScreenSizeForControls() { 
                if (window.innerWidth >= 768) { el.controlPanel.classList.add('open'); el.controlPanel.style.maxHeight = ''; } 
                else { if (!appState.controlPanelOpen) el.controlPanel.classList.remove('open');}
            }
            window.addEventListener('resize', checkScreenSizeForControls);
            checkScreenSizeForControls(); 
        };

        // --- Internationalization Function ---
        const updateUILanguage = () => {
            const lang = appState.uiLanguage;
            const strings = uiStrings[lang];
            document.querySelectorAll('[data-translate]').forEach(elem => {
                const key = elem.dataset.translate;
                if (strings[key]) {
                    if (key === 'reviewCountText' || key === 'learnedCountText') {
                        const count = key === 'reviewCountText' ? getDeckState().reviewIds.size : getDeckState().learnedIds.size;
                        elem.textContent = strings[key].replace("{count}", count);
                    } else if (key === 'progressLabel') {
                        const deckState = getDeckState();
                        const totalItems = appState.currentDeck.length;
                        const reviewedItems = totalItems > 0 ? deckState.currentIndex + 1 : 0;
                        elem.innerHTML = strings[key].replace("{reviewed}", reviewedItems).replace("{total}", totalItems);
                    } else if (key === 'accuracyLabel') {
                         const deckState = getDeckState();
                         const accuracy = deckState.quizAttempts > 0 ? ((deckState.quizCorrect / deckState.quizAttempts) * 100) : 0;
                         elem.innerHTML = strings[key].replace("{accuracy}", deckState.quizAttempts > 0 ? `${accuracy.toFixed(0)}%` : 'N/A');
                    } else if (key.startsWith('authStatus')) {
                        if (appState.currentUser) {
                             elem.textContent = appState.currentUser.isAnonymous ? strings.authStatusGuest : strings.authStatusLoggedInAs.replace("{email}", appState.currentUser.email);
                        } else {
                             elem.textContent = strings.authStatusNotLoggedIn;
                        }
                    }
                    else {
                        const textNode = Array.from(elem.childNodes).find(node => node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '');
                        if (textNode) {
                            textNode.textContent = strings[key];
                        } else if (elem.querySelector('span[data-translate-inner]')) { 
                            elem.querySelector('span[data-translate-inner]').textContent = strings[key];
                        }
                         else {
                             elem.textContent = strings[key]; 
                        }
                    }
                }
            });
            updatePinyinToggleButtonsState();
            el.languageToggleBtn.textContent = appState.uiLanguage === 'en' ? "中文" : "EN";
        };


        // --- APP START ---
        const startApp = async () => {
            console.log("App starting (v1.12 - Redesign)...");
            setupDOMReferences(); 
            console.log("DOM References set up.");

            let userProvidedConfig = { 
                apiKey: "AIzaSyA2AfVGf9BeQ0EH2_dPMyDyW17PTDnIzhw",
                authDomain: "lingualflow-eecd2.firebaseapp.com",
                projectId: "lingualflow-eecd2",
                storageBucket: "lingualflow-eecd2.appspot.com",
                messagingSenderId: "337589259202",
                appId: "1:337589259202:web:a21e6fbd67f1b34c3fe45b",
                measurementId: "G-3DCPWXRZG3"
            };

            if (typeof __firebase_config !== 'undefined' && __firebase_config && __firebase_config.trim() !== "") {
                try {
                    currentFirebaseConfig = JSON.parse(__firebase_config);
                    if (!currentFirebaseConfig.apiKey || !currentFirebaseConfig.projectId) {
                        throw new Error("Firebase config from __firebase_config is missing essential fields.");
                    }
                    currentAppId = currentFirebaseConfig.appId || (typeof __app_id !== 'undefined' ? __app_id : 'hanziflow-from-env');
                } catch (e) {
                    console.error("Error parsing __firebase_config:", e, ". Falling back to user-provided config.");
                    currentFirebaseConfig = userProvidedConfig;
                    currentAppId = currentFirebaseConfig.appId || 'hanziflow-user-config';
                    if (el.messageBox) showMessage("Using manually set Firebase config due to environment config error.", "info"); else console.info("Using manually set Firebase config due to environment config error.");
                }
            } else { 
                currentFirebaseConfig = userProvidedConfig;
                currentAppId = currentFirebaseConfig.appId || 'hanziflow-user-config';
                console.warn("Using manually set Firebase config as __firebase_config is not defined.");
            }
            
            try {
                firebaseApp = initializeApp(currentFirebaseConfig);
                auth = getAuth(firebaseApp);
                db = getFirestore(firebaseApp);
                console.log("Firebase Initialized. Project ID:", currentFirebaseConfig.projectId, "App ID for Firestore:", currentAppId);
            } catch (error) {
                console.error("CRITICAL: Error initializing Firebase services:", error);
                if (el.messageBox) showMessage("Could not initialize Firebase. App cannot function.", "error", 30000); else alert("Could not initialize Firebase.");
                updateUIForAuthState(null); 
                return; 
            }

            setupAuthEventListeners(); 
            console.log("Auth event listeners set up.");
            setupAppEventListeners(); 
            console.log("App event listeners set up.");
            updateFlashcardAnimation(); 
            console.log("Initial flashcard animation state set.");


            if (!auth || !db) { 
                 if (el.messageBox) showMessage("Firebase services not available. Cannot proceed.", "error", 10000); else alert("Firebase services not available.");
                 updateUIForAuthState(null); 
                 return;
            }

            onAuthStateChanged(auth, async (user) => {
                console.log("onAuthStateChanged triggered. User:", user ? user.uid : 'null');
                appState.currentUser = user;
                if (user) {
                    appState.isAnonymousUser = user.isAnonymous;
                    appState.userId = user.uid; 
                    console.log("User state changed. UID:", user.uid, "Is Anonymous:", user.isAnonymous);
                } else {
                    appState.isAnonymousUser = false; 
                    appState.userId = null;
                    console.log("User logged out or no user.");
                }
                updateUIForAuthState(user); 
                await loadProgress();      
                await initializeDeck();    
            });
            
            if (currentFirebaseConfig.apiKey === "YOUR_API_KEY_HERE" || currentFirebaseConfig.projectId === "YOUR_PROJECT_ID") {
                updateUIForAuthState(null); 
                if (el.messageBox) showMessage("Firebase is not configured with your project details. Please update the firebaseConfig in the script.", "error", 15000);
                else alert("Firebase not configured. Update script.");
                return; 
            }

            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token && auth) {
                try {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                }
            } else if (auth && !auth.currentUser) { 
                console.log("No initial auth token and no current user. User needs to login/signup or continue as guest.");
            }
        }

        document.addEventListener('DOMContentLoaded', startApp);
    </script>
</body>
</html>
