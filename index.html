<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HanziFlow - Learn Chinese</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --modern-red: #C0392B; --modern-red-darker: #A93226;
            --accent-gold: #B08D57; --accent-gold-lighter: #D4AF37;
            --bg-off-white: #FDFBF5; --text-dark-gray: #34495E;
            --border-light-gray: #EAEAEA; --subtle-bg: #F8F6F0;
        }
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif; overscroll-behavior-y: contain; 
            background-color: var(--bg-off-white); color: var(--text-dark-gray);
        }
        .chinese-char { font-family: 'Noto Sans SC', sans-serif; font-size: 2.2rem; line-height: 1.2; min-height: 2.6rem; color: var(--text-dark-gray); }
        .chinese-char-quiz { font-family: 'Noto Sans SC', sans-serif; font-size: 2rem; line-height: 1.2; min-height: 2.4rem; color: var(--text-dark-gray); }
        .pinyin-text { font-size: 0.9rem; color: #7f8c8d; min-height: 1.1rem; }
        .translation-text { font-size: 1rem; min-height: 1.2rem; color: var(--text-dark-gray); }
        .flip-card { perspective: 1000px; }
        .flip-card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; }
        .flip-card.flipped .flip-card-inner { transform: rotateY(180deg); }
        .flip-card-front, .flip-card-back {
            position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden;
            display: flex; flex-direction: column; align-items: center; padding: 20px; 
            border-radius: 0.75rem; box-shadow: 0 6px 12px -2px rgba(50, 50, 93, 0.15), 0 3px 7px -3px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border-light-gray);
        }
        .flip-card-front { background-color: white; justify-content: center; }
        .flip-card-back { background-color: var(--subtle-bg); transform: rotateY(180deg); justify-content: space-between; }
        .btn {
            padding: 0.6rem 1.2rem; border-radius: 0.5rem; font-weight: 500; 
            transition: background-color 0.2s, opacity 0.2s, transform 0.1s;
            cursor: pointer; border: 1px solid transparent; text-align: center; 
        }
        .btn:hover:not(:disabled) { transform: translateY(-1px); }
        .btn:active:not(:disabled) { transform: translateY(0px); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-theme-primary { background-color: var(--modern-red); color: white; border-color: var(--modern-red); }
        .btn-theme-primary:hover:not(:disabled) { background-color: var(--modern-red-darker); border-color: var(--modern-red-darker); }
        .btn-theme-secondary { background-color: var(--accent-gold); color: white; border-color: var(--accent-gold); }
        .btn-theme-secondary:hover:not(:disabled) { background-color: var(--accent-gold-lighter); border-color: var(--accent-gold-lighter); }
        .btn-theme-danger { background-color: #D9534F; color: white; }
        .btn-theme-danger:hover:not(:disabled) { background-color: #C9302C; }
        .btn-theme-outline { background-color: transparent; color: var(--modern-red); border-color: var(--modern-red); }
        .btn-theme-outline:hover:not(:disabled) { background-color: rgba(192, 57, 43, 0.05); }
        .btn-toggle.active { background-color: var(--accent-gold); color: white; border-color: var(--accent-gold); }
        .btn-toggle-group { gap: 0.25rem; }
        .btn-toggle-group button { background-color: white; color: var(--text-dark-gray); border: 1px solid var(--border-light-gray); }
        .btn-toggle-group button:hover:not(.active):not(:disabled) { background-color: var(--subtle-bg); }
        .quiz-choice.correct { background-color: #d1fae5; border-color: #10b981; color: #065f46; }
        .quiz-choice.incorrect { background-color: #fee2e2; border-color: #ef4444; color: #b91c1c; }
        .quiz-choice.reveal-correct { background-color: #a7f3d0; border-color: #059669; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        #messageBox {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 1rem 1.5rem; border-radius: 0.375rem; color: white;
            z-index: 1000; opacity: 0; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            min-width: 250px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #messageBox.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        #messageBox.success { background-color: #10b981; }
        #messageBox.error { background-color: #ef4444; }
        #messageBox.info { background-color: var(--modern-red); }
        #controlPanel {
            max-height: 0; overflow: hidden; transition: max-height 0.5s ease-in-out;
            background-color: white; border: 1px solid var(--border-light-gray);
            border-radius: 0.75rem; 
        }
        #controlPanel.open { max-height: 1000px; }
        .loading-placeholder { color: #9ca3af; font-style: italic; }
        .bar-container { width: 100%; background-color: #e5e7eb; border-radius: 9999px; height: 0.625rem; overflow: hidden; }
        .bar-fill { height: 100%; border-radius: 9999px; transition: width 0.3s ease-in-out; }
        #controlPanel > div:not(:last-child) { margin-bottom: 1rem; }
        #controlPanel > p { margin-top: 0.25rem; margin-bottom: 0.5rem; }
        .flashcard-back-content-wrapper { display: flex; flex-direction: column; justify-content: center; align-items: center; flex-grow: 1; }
        header h1 { color: var(--modern-red); }
        header h1 span { color: var(--accent-gold); }
        header p { color: #7f8c8d; }
        footer { border-top-color: var(--border-light-gray); }
        footer .text-slate-600 { color: #7f8c8d; }
        footer .bar-fill#progressBar { background-color: var(--modern-red); }
        footer .bar-fill#accuracyBar { background-color: var(--accent-gold); }
        footer .text-slate-400 { color: #95a5a6; }
        .auth-form input {
            border: 1px solid var(--border-light-gray); padding: 0.5rem 0.75rem;
            border-radius: 0.375rem; margin-bottom: 0.75rem; width: 100%;
        }
        .auth-form input:focus {
            outline: none; border-color: var(--accent-gold);
            box-shadow: 0 0 0 2px rgba(176, 141, 87, 0.3);
        }
    </style>
</head>
<body class="selection:bg-red-100">
    <div id="messageBox"></div>

    <header class="w-full max-w-4xl mb-8 text-center">
        <div class="flex justify-center items-center mb-1 relative">
            <h1 class="text-3xl md:text-4xl font-bold">
                HanziFlow <span class="text-xl font-medium">Ê±âÂ≠óÊµÅ</span>
            </h1>
            <button id="toggleControlsBtn" class="md:hidden absolute top-0 right-0 p-2 rounded-md hover:bg-gray-100">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-gray-600">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6h9.75M10.5 12h9.75m-9.75 6h9.75M3.75 6H6m-2.25 6H6m-2.25 6H6" />
                </svg>
            </button>
        </div>
        <p class="text-sm">Master Chinese, one card at a time.</p>
        <div id="authStatus" class="mt-2 text-xs">Connecting...</div>
        <button id="logoutBtn" class="btn btn-theme-outline text-xs py-1 px-2 mt-1 hidden">Logout</button>
    </header>

    <div id="authArea" class="w-full max-w-md mx-auto mb-8 p-6 bg-white rounded-xl shadow-lg border border-[var(--border-light-gray)]">
        <div id="loginFormContainer">
            <h2 class="text-xl font-semibold text-center mb-4 text-[var(--modern-red)]">Login</h2>
            <form id="loginForm" class="auth-form">
                <input type="email" id="loginEmail" placeholder="Email" required>
                <input type="password" id="loginPassword" placeholder="Password" required>
                <button type="submit" class="btn btn-theme-primary w-full">Login</button>
            </form>
            <p class="text-center text-sm mt-3">Don't have an account? <button id="showSignupBtn" class="text-[var(--accent-gold)] hover:underline">Sign Up</button></p>
        </div>
        <div id="signupFormContainer" class="hidden">
            <h2 class="text-xl font-semibold text-center mb-4 text-[var(--modern-red)]">Sign Up</h2>
            <form id="signupForm" class="auth-form">
                <input type="email" id="signupEmail" placeholder="Email" required>
                <input type="password" id="signupPassword" placeholder="Password (min. 6 characters)" required>
                <button type="submit" class="btn btn-theme-primary w-full">Sign Up</button>
            </form>
            <p class="text-center text-sm mt-3">Already have an account? <button id="showLoginBtn" class="text-[var(--accent-gold)] hover:underline">Login</button></p>
        </div>
    </div>

    <div id="appArea" class="hidden w-full max-w-4xl flex-col md:flex-row gap-6 px-2 sm:px-0">
        <aside id="controlPanelContainer" class="w-full md:w-1/3 lg:w-1/4">
            <div id="controlPanel" class="p-4 shadow-lg md:sticky md:top-8"> 
                <div>
                    <label class="block text-sm font-medium mb-1">Deck Source</label>
                    <div class="btn-toggle-group flex">
                        <button id="deckWordsBtn" class="btn flex-1 btn-toggle active">Words</button>
                        <button id="deckSentencesBtn" class="btn flex-1 btn-toggle">Sentences</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Mode</label>
                    <div class="btn-toggle-group flex">
                        <button id="modeFlashcardBtn" class="btn flex-1 btn-toggle active">Flashcard</button>
                        <button id="modeQuizBtn" class="btn flex-1 btn-toggle">Quiz</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Character Set</label>
                    <div class="btn-toggle-group flex">
                        <button id="charSimplifiedBtn" class="btn flex-1 btn-toggle active">Simplified</button>
                        <button id="charTraditionalBtn" class="btn flex-1 btn-toggle">Traditional</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Pinyin</label>
                    <div class="btn-toggle-group flex">
                        <button id="pinyinShowBtn" class="btn flex-1 btn-toggle active">Show</button>
                        <button id="pinyinHideBtn" class="btn flex-1 btn-toggle">Hide</button>
                    </div>
                </div>
                <div id="quizTranslationToggleContainer">
                    <label class="block text-sm font-medium mb-1">Quiz Choices</label>
                    <div class="btn-toggle-group flex">
                        <button id="transEnBtn" class="btn flex-1 btn-toggle active">English</button>
                        <button id="transThBtn" class="btn flex-1 btn-toggle">Thai</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Deck View</label>
                    <div class="btn-toggle-group flex flex-wrap"> 
                        <button id="deckAllBtn" class="btn flex-grow sm:flex-1 btn-toggle active mb-1 sm:mb-0">All</button>
                        <button id="deckReviewBtn" class="btn flex-grow sm:flex-1 btn-toggle mb-1 sm:mb-0">Review</button>
                        <button id="deckUnlearnedBtn" class="btn flex-grow sm:flex-1 btn-toggle">Unlearned</button>
                    </div>
                </div>
                 <p id="reviewDeckCount" class="text-xs text-center">Review: 0</p>
                 <p id="learnedDeckCount" class="text-xs text-center">Learned: 0</p>
                <div class="flex items-center justify-between">
                    <label for="autoAdvanceToggle" class="text-sm font-medium">Auto-Advance</label>
                    <button id="autoAdvanceToggle" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200">
                        <span class="sr-only">Auto-Advance</span>
                        <span id="autoAdvanceToggleKnob" class="inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out translate-x-1"></span>
                    </button>
                </div>
            </div>
        </aside>

        <main class="w-full md:w-2/3 lg:w-3/4 flex-1">
            <div id="flashcardMode" class="h-72 md:h-80"> 
                <div id="flashcard" class="flip-card w-full h-full">
                    <div class="flip-card-inner">
                        <div id="flashcardFront" class="flip-card-front">
                            <div id="flashcardChar" class="chinese-char mb-1"></div>
                            <div id="flashcardPinyin" class="pinyin-text"></div>
                        </div>
                        <div id="flashcardBack" class="flip-card-back">
                            <div class="flashcard-back-content-wrapper">
                                <div id="flashcardEn" class="translation-text mb-1 font-semibold"></div>
                                <div id="flashcardTh" class="translation-text mb-1"></div>
                                <div id="flashcardPinyinBack" class="pinyin-text mt-1"></div>
                            </div>
                            <div id="flashcardFeedbackButtons" class="w-full flex flex-col sm:flex-row sm:justify-center gap-2 sm:gap-3 pt-3">
                                <button id="reviewAgainBtn" class="btn btn-theme-outline flex-1">Review Again</button>
                                <button id="rememberBtn" class="btn btn-theme-outline flex-1" style="color: var(--accent-gold); border-color: var(--accent-gold);">I Remember It</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="quizMode" class="hidden bg-white p-6 rounded-xl shadow-lg border border-[var(--border-light-gray)]">
                <div id="quizQuestionArea" class="text-center mb-6">
                    <div id="quizChar" class="chinese-char-quiz mb-1"></div>
                    <div id="quizPinyin" class="pinyin-text"></div>
                </div>
                <div id="quizChoicesArea" class="grid grid-cols-1 sm:grid-cols-2 gap-3"></div>
                <div id="quizFeedback" class="mt-4 text-center font-semibold"></div>
            </div>

            <div id="navigationButtons" class="mt-6 flex flex-col space-y-2 sm:flex-row sm:space-y-0 sm:justify-center sm:gap-3">
                <button id="prevBtn" class="btn btn-theme-secondary w-full sm:w-auto">Previous</button>
                <button id="nextBtn" class="btn btn-theme-secondary w-full sm:w-auto">Next</button>
            </div>
        </main>
    </div>
    
    <div id="deckActionsArea" class="hidden w-full max-w-4xl mt-8 flex-col sm:flex-row justify-center items-center gap-3">
        <button id="shuffleDeckBtn" class="btn btn-theme-primary w-full sm:w-auto">Shuffle Current Deck</button>
        <button id="resetProgressBtn" class="btn btn-theme-danger w-full sm:w-auto">Reset All Progress</button>
    </div>

    <footer id="footerArea" class="hidden w-full max-w-4xl mt-6 pt-6 border-t"> 
        <div class="grid grid-cols-2 gap-x-4 gap-y-2 items-center text-sm mb-2"> 
            <div>Progress: <span id="progressText">0/0</span></div>
            <div id="accuracyDisplayContainer" class="text-right">Accuracy: <span id="accuracyText">N/A</span></div>
            <div class="bar-container">
                <div id="progressBar" class="bar-fill"></div>
            </div>
            <div class="bar-container">
                <div id="accuracyBar" class="bar-fill"></div>
            </div>
        </div>
         <p class="text-xs text-center mt-4">HanziFlow v1.9 - Firebase Sync</p>
    </footer>

    <script type="module">
        // Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut, 
            onAuthStateChanged,
            signInWithCustomToken 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc,
            deleteDoc 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        let firebaseConfigFromUser = {
            apiKey: "AIzaSyA2AfVGf9BeQ0EH2_dPMyDyW17PTDnIzhw",
            authDomain: "lingualflow-eecd2.firebaseapp.com",
            projectId: "lingualflow-eecd2",
            storageBucket: "lingualflow-eecd2.firebasestorage.app", // Corrected: .appspot.com
            messagingSenderId: "337589259202",
            appId: "1:337589259202:web:a21e6fbd67f1b34c3fe45b",
            measurementId: "G-3DCPWXRZG3" // measurementId is optional for Auth/Firestore
        };

        let firebaseConfig;
        let appId = typeof __app_id !== 'undefined' ? __app_id : 'hanziflow-default-app'; 

        if (typeof __firebase_config !== 'undefined' && __firebase_config && __firebase_config.trim() !== "") {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
                if (!firebaseConfig.apiKey || !firebaseConfig.projectId) {
                    throw new Error("Firebase config from __firebase_config is missing essential fields (apiKey, projectId).");
                }
                 appId = firebaseConfig.appId || appId; 
            } catch (e) {
                console.error("Error parsing __firebase_config:", e);
                firebaseConfig = firebaseConfigFromUser; // Fallback to user-provided if __firebase_config fails
                appId = firebaseConfig.appId || appId;
                showMessage("Using provided Firebase config due to __firebase_config error.", "info");
            }
        } else {
            firebaseConfig = firebaseConfigFromUser;
            appId = firebaseConfig.appId || appId;
            console.warn("Using user-provided Firebase config as __firebase_config is not defined.");
        }
        
        // Initialize Firebase
        let firebaseApp;
        let auth;
        let db;

        try {
            firebaseApp = initializeApp(firebaseConfig);
            auth = getAuth(firebaseApp);
            db = getFirestore(firebaseApp);
            console.log("Firebase Initialized. Project ID:", firebaseConfig.projectId, "App ID for Firestore:", appId);
        } catch (error) {
            console.error("Error initializing Firebase:", error);
            showMessage("Could not initialize Firebase. App features requiring Firebase will not work.", "error", 10000);
        }


        // --- DATA URLs ---
        const DATA_URLS = {
            words: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRtb5XXT0vCnmLWPrtrFYXp8gcLpg9AKusdIx4KiMLbmWCGhgcUCuq0J4x8fr_Tq3afGFxd3u8cAzEc/pub?gid=961444178&single=true&output=csv',
            sentences: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRtb5XXT0vCnmLWPrtrFYXp8gcLpg9AKusdIx4KiMLbmWCGhgcUCuq0J4x8fr_Tq3afGFxd3u8cAzEc/pub?gid=156031206&single=true&output=csv'
        };

        // --- STATE VARIABLES ---
        let appState = {
            deckSource: 'words', 
            currentMode: 'flashcard', 
            showSimplified: true, 
            showPinyin: true,
            quizTranslationLanguage: 'en', 
            deckViewType: 'all', 
            autoAdvance: false,
            masterDeck: [], 
            currentDeck: [], 
            progress: { 
                words: { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false },
                sentences: { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false }
            },
            isFlashcardFlipped: false,
            controlPanelOpen: false,
            isLoading: false,
            currentUser: null, 
            userId: null 
        };

        const el = {}; 

        // --- UTILITY FUNCTIONS ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showMessage(text, type = 'info', duration = 3000) {
            el.messageBox.textContent = text;
            el.messageBox.className = ''; 
            el.messageBox.classList.add('show', type);
            setTimeout(() => {
                el.messageBox.classList.remove('show');
            }, duration);
        }
        
        // --- DATA FETCHING AND PARSING (from CSV) ---
        async function fetchCSVData(url, idPrefix) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network response: ${response.statusText}`);
                const csvText = await response.text();
                return parseCSVToObjects(csvText, idPrefix);
            } catch (error) {
                console.error('Failed to fetch/parse CSV:', error);
                showMessage(`Error loading master deck: ${error.message}`, 'error', 5000);
                return [];
            }
        }

        function parseCSVToObjects(csvText, idPrefix) {
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length <= 1) return []; 
            const dataObjects = [];
            for (let i = 1; i < lines.length; i++) { 
                if (lines[i].trim() === '') continue; 
                const values = lines[i].split(','); 
                if (values.length >= 5) { 
                    dataObjects.push({
                        id: `${idPrefix}${i}`, 
                        s: values[0]?.trim()||'', t: values[1]?.trim()||'', 
                        p: values[2]?.trim()||'', en: values[3]?.trim()||'', 
                        th: values[4]?.trim()||''
                    });
                } else console.warn(`Skipping malformed CSV line ${i+1}: ${lines[i]}`);
            }
            return dataObjects;
        }
        
        // --- FIRESTORE DATA HANDLING ---
        function getDeckState() {
            return appState.progress[appState.deckSource];
        }

        async function loadUserProgressFromFirestore() {
            if (!appState.userId || !db) { 
                console.log("No user ID or Firestore DB not initialized, cannot load progress.");
                appState.progress.words = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false };
                appState.progress.sentences = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false };
                return;
            }

            for (const source of ['words', 'sentences']) {
                const docRef = doc(db, "artifacts", appId, "users", appState.userId, "progress", source);
                try {
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        appState.progress[source] = {
                            currentIndex: 0, 
                            quizAttempts: data.quizAttempts || 0,
                            quizCorrect: data.quizCorrect || 0,
                            reviewIds: new Set(data.reviewIds || []),
                            learnedIds: new Set(data.learnedIds || []),
                            quizAnsweredCurrent: false
                        };
                    } else {
                        appState.progress[source] = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false };
                        console.log(`No progress document found for ${source}, initializing fresh.`);
                    }
                } catch (error) {
                    console.error(`Error loading progress for ${source}:`, error);
                    showMessage(`Error loading your progress for ${source}.`, 'error');
                    appState.progress[source] = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false };
                }
            }
        }

        async function saveDeckStateToFirestore() {
            if (!appState.userId || !db) {
                console.warn("No user ID or Firestore DB not initialized, cannot save progress.");
                return;
            }
            const deckState = getDeckState();
            const source = appState.deckSource;
            if (!appId || appId.includes("YOUR_") || appId.includes("MISSING_") || appId.includes("INVALID_")) {
                console.error("Invalid appId for Firestore path:", appId, "Cannot save progress.");
                showMessage("Error: App ID for database is not configured correctly.", "error");
                return;
            }
            const docRef = doc(db, "artifacts", appId, "users", appState.userId, "progress", source);
            
            const dataToSave = {
                quizAttempts: deckState.quizAttempts,
                quizCorrect: deckState.quizCorrect,
                reviewIds: Array.from(deckState.reviewIds),
                learnedIds: Array.from(deckState.learnedIds)
            };

            try {
                await setDoc(docRef, dataToSave, { merge: true }); 
                console.log(`Progress for ${source} saved to Firestore.`);
            } catch (error) {
                console.error(`Error saving progress for ${source}:`, error);
                showMessage(`Error saving your progress.`, 'error');
            }
        }
        
        async function resetUserProgressInFirestore(deckSourceToReset) {
            if (!appState.userId || !db) return;
            if (!appId || appId.includes("YOUR_") || appId.includes("MISSING_") || appId.includes("INVALID_")) {
                console.error("Invalid appId for Firestore path:", appId, "Cannot reset progress.");
                return;
            }
            const docRef = doc(db, "artifacts", appId, "users", appState.userId, "progress", deckSourceToReset);
            try {
                await setDoc(docRef, {
                    quizAttempts: 0, quizCorrect: 0, reviewIds: [], learnedIds: []
                });
                console.log(`Progress for ${deckSourceToReset} reset in Firestore.`);
            } catch (error) {
                console.error(`Error resetting progress for ${deckSourceToReset}:`, error);
                showMessage(`Error resetting progress.`, 'error');
            }
        }


        // --- INITIALIZATION AND DATA LOADING ---
        async function initializeDeck() { 
            appState.isLoading = true;
            setLoadingState(true);
            
            const url = DATA_URLS[appState.deckSource];
            const idPrefix = appState.deckSource === 'words' ? 'w' : 's';
            
            appState.masterDeck = await fetchCSVData(url, idPrefix);
            shuffleArray(appState.masterDeck); 
            
            appState.isLoading = false;
            setLoadingState(false);

            if (appState.masterDeck.length === 0 && url) { 
                 showMessage(`No items found in ${appState.deckSource} deck. Check data source.`, 'error', 5000);
            }
            
            const currentDeckState = getDeckState();
            currentDeckState.currentIndex = 0; 
            currentDeckState.quizAnsweredCurrent = false; 
            
            filterAndSetCurrentDeck(); 
            updateDisplay();
        }
        
        // --- UI State Updates ---
        function setLoadingState(isLoading) { /* ... (same as v1.7) ... */ }
        function filterAndSetCurrentDeck() { /* ... (same as v1.7) ... */ }
        function updateDisplay() { /* ... (same as v1.7) ... */ }
        function updateToggleButtonStates() { /* ... (same as v1.7) ... */ }
        function updateModeVisibility() { /* ... (same as v1.7, ensure el.flashcardFeedbackButtons check) ... */ }
        function updateNavigationButtons() { /* ... (same as v1.7) ... */ }
        function updateProgressAndAccuracy() { /* ... (same as v1.7) ... */ }
        function updateStatusCounts() { /* ... (same as v1.7) ... */ }
        function flipCard() { /* ... (same as v1.7) ... */ }
        function handleFlashcardFeedback(isRemembered) { /* ... (uses saveDeckStateToFirestore) ... */ }
        function renderQuizChoices(currentItem) { /* ... (same as v1.7) ... */ }
        function handleQuizAnswer(isCorrect, clickedButton, correctAnswerText) { /* ... (uses saveDeckStateToFirestore) ... */ }
        function goToNextItem() { /* ... (same as v1.7) ... */ }
        function goToPrevItem() { /* ... (same as v1.7) ... */ }
        
        // --- Simplified versions of unchanged functions for brevity in this example ---
        setLoadingState = function(isLoading) {
            appState.isLoading = isLoading;
            const loadingText = "Loading...";
            if (!el.flashcardChar || !el.quizChar) return; 

            if (isLoading) {
                if (appState.currentMode === 'flashcard') {
                    el.flashcardChar.textContent = loadingText; el.flashcardChar.classList.add('loading-placeholder');
                    el.flashcardPinyin.textContent = ''; el.flashcardEn.textContent = ''; el.flashcardTh.textContent = '';
                } else {
                    el.quizChar.textContent = loadingText; el.quizChar.classList.add('loading-placeholder');
                    el.quizPinyin.textContent = ''; el.quizChoicesArea.innerHTML = '';
                }
                 document.querySelectorAll('#appArea button, #deckActionsArea button, #controlPanel button').forEach(btn => btn.disabled = true);
            } else {
                el.flashcardChar.classList.remove('loading-placeholder'); el.quizChar.classList.remove('loading-placeholder');
                document.querySelectorAll('#appArea button, #deckActionsArea button, #controlPanel button').forEach(btn => btn.disabled = false);
                if(el.shuffleDeckBtn) el.shuffleDeckBtn.disabled = appState.currentDeck.length === 0;
            }
            if(el.flashcardChar) updateDisplay(); 
        };
        filterAndSetCurrentDeck = function() {
            const deckState = getDeckState(); let deckToUse = [];
            if (appState.deckViewType === 'all') deckToUse = [...appState.masterDeck];
            else if (appState.deckViewType === 'review') {
                deckToUse = appState.masterDeck.filter(item => deckState.reviewIds.has(item.id)); shuffleArray(deckToUse);
            } else if (appState.deckViewType === 'unlearned') {
                deckToUse = appState.masterDeck.filter(item => !deckState.learnedIds.has(item.id)); shuffleArray(deckToUse);
            }
            appState.currentDeck = deckToUse;
            if(el.shuffleDeckBtn) el.shuffleDeckBtn.disabled = appState.isLoading || appState.currentDeck.length === 0;
            if (deckState.currentIndex >= appState.currentDeck.length) deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
            if (appState.currentDeck.length === 0 && appState.masterDeck.length > 0) {
                showMessage(`${appState.deckViewType.charAt(0).toUpperCase() + appState.deckViewType.slice(1)} deck is empty.`, "info");
            }
        };
        updateDisplay = function() {
            if (!el.deckWordsBtn) return; 
            updateToggleButtonStates(); updateModeVisibility(); updateNavigationButtons();
            updateProgressAndAccuracy(); updateStatusCounts();
            if (appState.isLoading) {
                if(el.prevBtn) el.prevBtn.disabled = true; if(el.nextBtn) el.nextBtn.disabled = true;
                if(el.quizChoicesArea) el.quizChoicesArea.innerHTML = ''; return;
            }
            const deckState = getDeckState();
            if (appState.currentDeck.length === 0) {
                const msg = `${appState.deckViewType.charAt(0).toUpperCase() + appState.deckViewType.slice(1)} Deck Empty`;
                if (appState.currentMode === 'flashcard') {
                    el.flashcardChar.textContent = msg; el.flashcardPinyin.textContent = ''; el.flashcardEn.textContent = '';
                    el.flashcardTh.textContent = ''; el.flashcardPinyinBack.textContent = '';
                    el.flashcard.classList.remove('flipped'); appState.isFlashcardFlipped = false;
                } else {
                    el.quizChar.textContent = msg; el.quizPinyin.textContent = '';
                    el.quizChoicesArea.innerHTML = ''; el.quizFeedback.textContent = '';
                }
                if(el.prevBtn) el.prevBtn.disabled = true; if(el.nextBtn) el.nextBtn.disabled = true; return;
            }
            if (deckState.currentIndex >= appState.currentDeck.length) deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
            if (deckState.currentIndex < 0 && appState.currentDeck.length > 0) deckState.currentIndex = 0;
            const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) {
                el.flashcardChar.textContent = 'Error.'; if(el.prevBtn) el.prevBtn.disabled = true; if(el.nextBtn) el.nextBtn.disabled = true; return;
            }
            const charToDisplay = appState.showSimplified ? currentItem.s : currentItem.t;
            const pinyinToDisplay = appState.showPinyin ? currentItem.p : '';
            if (appState.currentMode === 'flashcard') {
                el.flashcardChar.textContent = charToDisplay; el.flashcardPinyin.textContent = pinyinToDisplay;
                el.flashcardEn.textContent = currentItem.en; el.flashcardTh.textContent = currentItem.th;
                el.flashcardPinyinBack.textContent = pinyinToDisplay;
                el.flashcard.classList.toggle('flipped', appState.isFlashcardFlipped);
            } else {
                el.quizChar.textContent = charToDisplay; el.quizPinyin.textContent = pinyinToDisplay;
                if (!deckState.quizAnsweredCurrent) { renderQuizChoices(currentItem); el.quizFeedback.textContent = ''; }
            }
        };
        updateToggleButtonStates = function() { /* ... same ... */ 
            el.deckWordsBtn.classList.toggle('active', appState.deckSource === 'words');
            el.deckSentencesBtn.classList.toggle('active', appState.deckSource === 'sentences');
            el.modeFlashcardBtn.classList.toggle('active', appState.currentMode === 'flashcard');
            el.modeQuizBtn.classList.toggle('active', appState.currentMode === 'quiz');
            el.charSimplifiedBtn.classList.toggle('active', appState.showSimplified);
            el.charTraditionalBtn.classList.toggle('active', !appState.showSimplified);
            el.pinyinShowBtn.classList.toggle('active', appState.showPinyin);
            el.pinyinHideBtn.classList.toggle('active', !appState.showPinyin);
            el.transEnBtn.classList.toggle('active', appState.quizTranslationLanguage === 'en');
            el.transThBtn.classList.toggle('active', appState.quizTranslationLanguage === 'th');
            el.deckAllBtn.classList.toggle('active', appState.deckViewType === 'all');
            el.deckReviewBtn.classList.toggle('active', appState.deckViewType === 'review');
            el.deckUnlearnedBtn.classList.toggle('active', appState.deckViewType === 'unlearned');
            el.autoAdvanceToggle.classList.toggle('bg-[var(--modern-red)]', appState.autoAdvance);
            el.autoAdvanceToggle.classList.toggle('bg-gray-200', !appState.autoAdvance);
            el.autoAdvanceToggleKnob.classList.toggle('translate-x-5', appState.autoAdvance);
            el.autoAdvanceToggleKnob.classList.toggle('translate-x-1', !appState.autoAdvance);
        };
        updateModeVisibility = function() { 
            const isFlashcard = appState.currentMode === 'flashcard';
            el.flashcardModeDiv.classList.toggle('hidden', !isFlashcard);
            el.quizModeDiv.classList.toggle('hidden', isFlashcard);
            el.quizTranslationToggleContainer.classList.toggle('hidden', isFlashcard); 
            el.accuracyDisplayContainer.classList.toggle('hidden', isFlashcard); 
            if (!appState.isLoading) getDeckState().quizAnsweredCurrent = false; 
        };
        updateNavigationButtons = function() { /* ... same ... */ 
            el.navigationButtons.classList.toggle('hidden', appState.autoAdvance || appState.isLoading);
            const deckState = getDeckState();
            if (appState.currentDeck.length === 0 || appState.isLoading) {
                el.prevBtn.disabled = true; el.nextBtn.disabled = true;
            } else {
                el.prevBtn.disabled = deckState.currentIndex === 0;
                el.nextBtn.disabled = deckState.currentIndex === appState.currentDeck.length - 1;
            }
        };
        updateProgressAndAccuracy = function() { /* ... same ... */ 
            const deckState = getDeckState();
            const totalItems = appState.currentDeck.length;
            const reviewedItems = totalItems > 0 ? deckState.currentIndex + 1 : 0;
            el.progressText.textContent = `${reviewedItems}/${totalItems}`;
            el.progressBar.style.width = totalItems > 0 ? `${(reviewedItems / totalItems) * 100}%` : '0%';
            if (appState.currentMode === 'quiz') {
                const accuracy = deckState.quizAttempts > 0 ? ((deckState.quizCorrect / deckState.quizAttempts) * 100) : 0; 
                el.accuracyText.textContent = deckState.quizAttempts > 0 ? `${accuracy.toFixed(0)}%` : 'N/A';
                el.accuracyBar.style.width = `${accuracy}%`;
            } else {
                 el.accuracyText.textContent = 'N/A'; el.accuracyBar.style.width = '0%';
            }
        };
        updateStatusCounts = function() { /* ... same ... */ 
            const deckState = getDeckState();
            el.reviewDeckCount.textContent = `Review: ${deckState.reviewIds.size}`;
            el.learnedDeckCount.textContent = `Learned: ${deckState.learnedIds.size}`;
        };
        flipCard = function() { /* ... same ... */ 
            if (appState.isLoading || appState.currentDeck.length === 0) return;
            appState.isFlashcardFlipped = !appState.isFlashcardFlipped;
            el.flashcard.classList.toggle('flipped', appState.isFlashcardFlipped);
        };
        handleFlashcardFeedback = function(isRemembered) { /* ... (uses saveDeckStateToFirestore) ... */ 
            if (appState.isLoading || !appState.currentUser) return; 
            const deckState = getDeckState(); const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) return; 
            const charText = appState.showSimplified ? currentItem.s : currentItem.t;
            if (isRemembered) {
                showMessage(`"${charText}" marked as remembered.`, 'success', 1500);
                deckState.learnedIds.add(currentItem.id); deckState.reviewIds.delete(currentItem.id); 
            } else { 
                showMessage(`"${charText}" added to review.`, 'info', 1500);
                deckState.reviewIds.add(currentItem.id); deckState.learnedIds.delete(currentItem.id); 
            }
            saveDeckStateToFirestore(); updateStatusCounts(); 
            let deckNeedsRefilter = false;
            if (appState.deckViewType === 'unlearned' && isRemembered) deckNeedsRefilter = true;
            else if (appState.deckViewType === 'review' && isRemembered) deckNeedsRefilter = true;
            if (appState.autoAdvance) {
                if (deckNeedsRefilter) {
                    setTimeout(() => {
                        const oldIndex = deckState.currentIndex; filterAndSetCurrentDeck(); 
                        if (appState.currentDeck.length > 0) {
                            deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                            if (deckState.currentIndex < appState.currentDeck.length -1 || (appState.currentDeck.length === 1 && deckState.currentIndex === 0) ) {
                                if (!(appState.currentDeck.length > 0 && oldIndex === appState.currentDeck.length && isRemembered && appState.deckViewType !== 'all')) {
                                   goToNextItem();
                                } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                            } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                        } else { updateDisplay(); }
                    }, 600); 
                } else { setTimeout(goToNextItem, 500); }
            } else if (deckNeedsRefilter) { 
                const oldIndex = deckState.currentIndex; filterAndSetCurrentDeck();
                if (appState.currentDeck.length > 0) { 
                    deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                }
                updateDisplay(); 
            }
        };
        renderQuizChoices = function(currentItem) { /* ... same ... */ 
            el.quizChoicesArea.innerHTML = ''; 
            const correctAnswerLang = appState.quizTranslationLanguage === 'en' ? currentItem.en : currentItem.th;
            let choices = [correctAnswerLang];
            const distractors = appState.masterDeck.filter(item => item.id !== currentItem.id)
                .map(item => appState.quizTranslationLanguage === 'en' ? item.en : item.th)
                .filter((value, index, self) => value && self.indexOf(value) === index && value !== correctAnswerLang); 
            shuffleArray(distractors);
            choices = choices.concat(distractors.slice(0, Math.min(3, distractors.length))); 
            shuffleArray(choices); 
            choices.forEach(choiceText => {
                const choiceButton = document.createElement('button');
                choiceButton.className = 'btn btn-theme-outline w-full text-left p-3 quiz-choice';
                choiceButton.textContent = choiceText;
                choiceButton.onclick = () => handleQuizAnswer(choiceText === correctAnswerLang, choiceButton, correctAnswerLang);
                el.quizChoicesArea.appendChild(choiceButton);
            });
        };
        handleQuizAnswer = function(isCorrect, clickedButton, correctAnswerText) { /* ... (uses saveDeckStateToFirestore) ... */ 
            const deckState = getDeckState();
            if (deckState.quizAnsweredCurrent || appState.isLoading || !appState.currentUser) return; 
            deckState.quizAnsweredCurrent = true; deckState.quizAttempts++;
            const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) return; 
            const charText = appState.showSimplified ? currentItem.s : currentItem.t;
            let deckNeedsRefilter = false;
            if (isCorrect) {
                deckState.quizCorrect++;
                el.quizFeedback.textContent = 'Correct! üéâ'; el.quizFeedback.className = 'mt-4 text-center font-semibold text-green-600';
                clickedButton.className = 'btn w-full text-left p-3 quiz-choice correct';
                showMessage('Correct!', 'success', 1500);
                deckState.learnedIds.add(currentItem.id); deckState.reviewIds.delete(currentItem.id);
                if (appState.deckViewType === 'unlearned') deckNeedsRefilter = true;
            } else { 
                el.quizFeedback.innerHTML = `Incorrect. Correct: <span class="font-bold">${correctAnswerText}</span>`;
                el.quizFeedback.className = 'mt-4 text-center font-semibold text-red-600';
                clickedButton.className = 'btn w-full text-left p-3 quiz-choice incorrect';
                Array.from(el.quizChoicesArea.children).forEach(btn => {
                    if (btn.textContent === correctAnswerText) btn.className = 'btn w-full text-left p-3 quiz-choice reveal-correct';
                    btn.disabled = true; 
                });
                deckState.reviewIds.add(currentItem.id); deckState.learnedIds.delete(currentItem.id); 
                showMessage(`Added "${charText}" to review.`, 'error', 2000);
            }
            saveDeckStateToFirestore(); updateStatusCounts(); updateProgressAndAccuracy(); 
            if (appState.autoAdvance) {
                 if (deckNeedsRefilter) {
                    setTimeout(() => {
                        const oldIndex = deckState.currentIndex; filterAndSetCurrentDeck();
                        if (appState.currentDeck.length > 0) {
                            deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                            if (deckState.currentIndex < appState.currentDeck.length -1 || (appState.currentDeck.length === 1 && deckState.currentIndex === 0) || (!isCorrect && deckState.currentIndex <= appState.currentDeck.length -1) ) {
                                 if (!(appState.currentDeck.length > 0 && oldIndex === appState.currentDeck.length && isCorrect && appState.deckViewType !== 'all')) {
                                   goToNextItem();
                                } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                            } else { showMessage("End of filtered deck.", "info"); updateDisplay(); }
                        } else { updateDisplay(); }
                    }, isCorrect ? 1600 : 2600); 
                } else { setTimeout(goToNextItem, isCorrect ? 1500 : 2500); }
            } else if (deckNeedsRefilter) { 
                 const oldIndex = deckState.currentIndex; filterAndSetCurrentDeck();
                 if (appState.currentDeck.length > 0) { 
                    deckState.currentIndex = (oldIndex < appState.currentDeck.length) ? oldIndex : Math.max(0, appState.currentDeck.length - 1);
                }
                 updateDisplay(); 
            }
        };
        goToNextItem = function() { /* ... same ... */ 
            if (appState.isLoading) return;
            const deckState = getDeckState();
            if (deckState.currentIndex < appState.currentDeck.length - 1) {
                deckState.currentIndex++; appState.isFlashcardFlipped = false; 
                deckState.quizAnsweredCurrent = false; updateDisplay();
            } else if (appState.currentDeck.length > 0) { 
                showMessage("You've reached the end of the deck!", "info");
            }
        };
        goToPrevItem = function() { /* ... same ... */ 
            if (appState.isLoading) return;
            const deckState = getDeckState();
            if (deckState.currentIndex > 0) {
                deckState.currentIndex--; appState.isFlashcardFlipped = false;
                deckState.quizAnsweredCurrent = false; updateDisplay();
            }
        };
        setupDOMReferences = function() { /* ... same ... */ 
            el.authArea = document.getElementById('authArea');
            el.appArea = document.getElementById('appArea');
            el.deckActionsArea = document.getElementById('deckActionsArea');
            el.footerArea = document.getElementById('footerArea');
            el.loginForm = document.getElementById('loginForm');
            el.signupForm = document.getElementById('signupForm');
            el.loginEmail = document.getElementById('loginEmail');
            el.loginPassword = document.getElementById('loginPassword');
            el.signupEmail = document.getElementById('signupEmail');
            el.signupPassword = document.getElementById('signupPassword');
            el.showSignupBtn = document.getElementById('showSignupBtn');
            el.showLoginBtn = document.getElementById('showLoginBtn');
            el.logoutBtn = document.getElementById('logoutBtn');
            el.authStatus = document.getElementById('authStatus');
            el.loginFormContainer = document.getElementById('loginFormContainer');
            el.signupFormContainer = document.getElementById('signupFormContainer');
            el.deckWordsBtn = document.getElementById('deckWordsBtn');
            el.deckSentencesBtn = document.getElementById('deckSentencesBtn');
            el.modeFlashcardBtn = document.getElementById('modeFlashcardBtn');
            el.modeQuizBtn = document.getElementById('modeQuizBtn');
            el.charSimplifiedBtn = document.getElementById('charSimplifiedBtn');
            el.charTraditionalBtn = document.getElementById('charTraditionalBtn');
            el.pinyinShowBtn = document.getElementById('pinyinShowBtn');
            el.pinyinHideBtn = document.getElementById('pinyinHideBtn');
            el.quizTranslationToggleContainer = document.getElementById('quizTranslationToggleContainer');
            el.transEnBtn = document.getElementById('transEnBtn');
            el.transThBtn = document.getElementById('transThBtn');
            el.deckAllBtn = document.getElementById('deckAllBtn');
            el.deckReviewBtn = document.getElementById('deckReviewBtn');
            el.deckUnlearnedBtn = document.getElementById('deckUnlearnedBtn');
            el.reviewDeckCount = document.getElementById('reviewDeckCount');
            el.learnedDeckCount = document.getElementById('learnedDeckCount');
            el.autoAdvanceToggle = document.getElementById('autoAdvanceToggle');
            el.autoAdvanceToggleKnob = document.getElementById('autoAdvanceToggleKnob');
            el.shuffleDeckBtn = document.getElementById('shuffleDeckBtn');
            el.resetProgressBtn = document.getElementById('resetProgressBtn');
            el.flashcardModeDiv = document.getElementById('flashcardMode');
            el.quizModeDiv = document.getElementById('quizMode');
            el.flashcard = document.getElementById('flashcard');
            el.flashcardFront = document.getElementById('flashcardFront');
            el.flashcardChar = document.getElementById('flashcardChar');
            el.flashcardPinyin = document.getElementById('flashcardPinyin');
            el.flashcardBack = document.getElementById('flashcardBack');
            el.flashcardEn = document.getElementById('flashcardEn');
            el.flashcardTh = document.getElementById('flashcardTh');
            el.flashcardPinyinBack = document.getElementById('flashcardPinyinBack');
            el.flashcardFeedbackButtons = document.getElementById('flashcardFeedbackButtons'); 
            el.reviewAgainBtn = document.getElementById('reviewAgainBtn');
            el.rememberBtn = document.getElementById('rememberBtn');
            el.quizQuestionArea = document.getElementById('quizQuestionArea');
            el.quizChar = document.getElementById('quizChar');
            el.quizPinyin = document.getElementById('quizPinyin');
            el.quizChoicesArea = document.getElementById('quizChoicesArea');
            el.quizFeedback = document.getElementById('quizFeedback');
            el.navigationButtons = document.getElementById('navigationButtons');
            el.prevBtn = document.getElementById('prevBtn');
            el.nextBtn = document.getElementById('nextBtn');
            el.progressText = document.getElementById('progressText');
            el.progressBar = document.getElementById('progressBar');
            el.accuracyDisplayContainer = document.getElementById('accuracyDisplayContainer');
            el.accuracyText = document.getElementById('accuracyText');
            el.accuracyBar = document.getElementById('accuracyBar');
            el.messageBox = document.getElementById('messageBox');
            el.toggleControlsBtn = document.getElementById('toggleControlsBtn');
            el.controlPanel = document.getElementById('controlPanel'); 
        };
        function setupAuthEventListeners() { /* ... (same as v1.7, added specific error for email-already-in-use) ... */ 
             el.loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!auth) { showMessage("Firebase Auth not initialized.", "error"); return; }
                try {
                    await signInWithEmailAndPassword(auth, el.loginEmail.value, el.loginPassword.value);
                    showMessage('Logged in successfully!', 'success');
                } catch (error) {
                    showMessage(`Login failed: ${error.message}`, 'error');
                    console.error("Login error:", error);
                }
            });

            el.signupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!auth) { showMessage("Firebase Auth not initialized.", "error"); return; }
                try {
                    await createUserWithEmailAndPassword(auth, el.signupEmail.value, el.signupPassword.value);
                    showMessage('Signed up successfully! You are now logged in.', 'success');
                } catch (error) {
                    if (error.code === 'auth/operation-not-allowed') {
                        showMessage('Signup failed: Email/Password sign-in is not enabled for this app. Please check Firebase console settings.', 'error', 7000);
                        console.error("Signup error: auth/operation-not-allowed. This usually means Email/Password sign-in provider needs to be enabled in your Firebase project's Authentication settings.", error);
                    } else if (error.code === 'auth/email-already-in-use') {
                         showMessage('Signup failed: This email is already in use. Please try logging in.', 'error', 6000);
                    } else {
                        showMessage(`Signup failed: ${error.message}`, 'error');
                        console.error("Signup error:", error);
                    }
                }
            });

            el.logoutBtn.addEventListener('click', async () => {
                if (!auth) { showMessage("Firebase Auth not initialized.", "error"); return; }
                try {
                    await signOut(auth);
                    showMessage('Logged out.', 'info');
                } catch (error) {
                    showMessage(`Logout failed: ${error.message}`, 'error');
                }
            });

            el.showSignupBtn.addEventListener('click', () => {
                el.loginFormContainer.classList.add('hidden');
                el.signupFormContainer.classList.remove('hidden');
            });
            el.showLoginBtn.addEventListener('click', () => {
                el.signupFormContainer.classList.add('hidden');
                el.loginFormContainer.classList.remove('hidden');
            });
        }
        function updateUIForAuthState(user) { /* ... same as v1.7 ... */ 
            if (user) {
                el.authArea.classList.add('hidden');
                el.appArea.style.display = 'flex'; 
                el.deckActionsArea.style.display = 'flex';
                el.footerArea.style.display = 'block'; 
                el.authStatus.textContent = `Logged in as: ${user.email || 'User'}`;
                el.logoutBtn.classList.remove('hidden');
            } else {
                el.authArea.classList.remove('hidden');
                el.appArea.style.display = 'none';
                el.deckActionsArea.style.display = 'none'; 
                el.footerArea.style.display = 'none';
                el.authStatus.textContent = 'Not logged in.';
                el.logoutBtn.classList.add('hidden');
                if(el.progressText) el.progressText.textContent = '0/0';
                if(el.progressBar) el.progressBar.style.width = '0%';
                if(el.accuracyText) el.accuracyText.textContent = 'N/A';
                if(el.accuracyBar) el.accuracyBar.style.width = '0%';
                if(el.reviewDeckCount) el.reviewDeckCount.textContent = 'Review: 0';
                if(el.learnedDeckCount) el.learnedDeckCount.textContent = 'Learned: 0';
            }
        }
        function setupAppEventListeners() { /* ... same as v1.7 (uses saveDeckStateToFirestore, resetUserProgressInFirestore) ... */ 
            el.deckWordsBtn.addEventListener('click', async () => {
                if (appState.isLoading || appState.deckSource === 'words') return;
                appState.deckSource = 'words';
                await initializeDeck(); 
            });
            el.deckSentencesBtn.addEventListener('click', async () => {
                if (appState.isLoading || appState.deckSource === 'sentences') return;
                appState.deckSource = 'sentences';
                await initializeDeck(); 
            });
            el.modeFlashcardBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.currentMode = 'flashcard'; appState.isFlashcardFlipped = false; updateDisplay();} });
            el.modeQuizBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.currentMode = 'quiz';updateDisplay();} });
            el.charSimplifiedBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showSimplified = true; updateDisplay();} });
            el.charTraditionalBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showSimplified = false; updateDisplay();} });
            el.pinyinShowBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showPinyin = true; updateDisplay();} });
            el.pinyinHideBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showPinyin = false; updateDisplay();} });
            el.transEnBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.quizTranslationLanguage = 'en'; getDeckState().quizAnsweredCurrent = false; updateDisplay(); }});
            el.transThBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.quizTranslationLanguage = 'th'; getDeckState().quizAnsweredCurrent = false; updateDisplay(); }});
            el.deckAllBtn.addEventListener('click', () => { if (!appState.isLoading && appState.deckViewType !== 'all') {appState.deckViewType = 'all'; getDeckState().currentIndex = 0; filterAndSetCurrentDeck(); updateDisplay();}});
            el.deckReviewBtn.addEventListener('click', () => { if (!appState.isLoading && appState.deckViewType !== 'review') {appState.deckViewType = 'review'; getDeckState().currentIndex = 0; filterAndSetCurrentDeck(); updateDisplay();}});
            el.deckUnlearnedBtn.addEventListener('click', () => { if (!appState.isLoading && appState.deckViewType !== 'unlearned') {appState.deckViewType = 'unlearned'; getDeckState().currentIndex = 0; filterAndSetCurrentDeck(); updateDisplay();}});
            el.autoAdvanceToggle.addEventListener('click', () => { if (!appState.isLoading) {appState.autoAdvance = !appState.autoAdvance; updateDisplay();}});
            el.shuffleDeckBtn.addEventListener('click', () => {
                if (appState.isLoading || appState.currentDeck.length === 0) return;
                shuffleArray(appState.currentDeck); 
                getDeckState().currentIndex = 0; 
                appState.isFlashcardFlipped = false; getDeckState().quizAnsweredCurrent = false;
                showMessage("Current deck view shuffled!", "success", 1500); updateDisplay();
            });
            el.resetProgressBtn.addEventListener('click', async () => {
                if (appState.isLoading || !appState.currentUser) return;
                const userConfirmed = window.confirm("Are you sure you want to reset all progress for this deck source? This will clear learned items, review items, and quiz scores from your account for this deck.");
                if (!userConfirmed) return;
                const deckSourceToReset = appState.deckSource;
                await resetUserProgressInFirestore(deckSourceToReset);
                appState.progress[deckSourceToReset] = { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false };
                filterAndSetCurrentDeck(); 
                showMessage(`Progress for ${deckSourceToReset} deck has been reset.`, "info");
                updateDisplay();
            });
            el.flashcard.addEventListener('click', (e) => { 
                if (appState.isLoading) return;
                if (e.target.closest('#reviewAgainBtn') || e.target.closest('#rememberBtn')) return; 
                if (appState.currentMode === 'flashcard' && appState.currentDeck.length > 0) flipCard();
            });
            el.reviewAgainBtn.addEventListener('click', () => handleFlashcardFeedback(false));
            el.rememberBtn.addEventListener('click', () => handleFlashcardFeedback(true));
            el.prevBtn.addEventListener('click', goToPrevItem);
            el.nextBtn.addEventListener('click', goToNextItem);
            document.addEventListener('keydown', (e) => { 
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || appState.isLoading) return; 
                if (appState.autoAdvance && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ')) return; 
                if (e.key === 'ArrowLeft') goToPrevItem();
                else if (e.key === 'ArrowRight') goToNextItem();
                else if (e.key === ' ' && appState.currentMode === 'flashcard') { e.preventDefault(); flipCard(); }
            });
            el.toggleControlsBtn.addEventListener('click', () => { appState.controlPanelOpen = !appState.controlPanelOpen; el.controlPanel.classList.toggle('open', appState.controlPanelOpen);});
            function checkScreenSizeForControls() { 
                if (window.innerWidth >= 768) { el.controlPanel.classList.add('open'); el.controlPanel.style.maxHeight = ''; } 
                else { if (!appState.controlPanelOpen) el.controlPanel.classList.remove('open');}
            }
            window.addEventListener('resize', checkScreenSizeForControls);
            checkScreenSizeForControls(); 
        }

        // --- APP START ---
        async function startApp() {
            console.log("App starting...");
            setupDOMReferences(); 
            setupAuthEventListeners(); 
            setupAppEventListeners(); 

            if (!auth || !db) {
                 showMessage("Firebase not properly initialized. Cannot proceed.", "error", 10000);
                 updateUIForAuthState(null); 
                 return;
            }

            onAuthStateChanged(auth, async (user) => {
                appState.currentUser = user;
                appState.userId = user ? user.uid : null;
                updateUIForAuthState(user);

                if (user) {
                    console.log("User logged in:", user.uid);
                    await loadUserProgressFromFirestore(); 
                    await initializeDeck(); 
                } else {
                    console.log("User logged out or no user.");
                    await loadUserProgressFromFirestore(); 
                    await initializeDeck(); 
                }
            });
            
            // Check if the provided config seems like placeholders
            if (firebaseConfig.apiKey === "YOUR_API_KEY_HERE" || firebaseConfig.projectId === "YOUR_PROJECT_ID") {
                updateUIForAuthState(null); 
                showMessage("Firebase is not configured with your project details. Please update the firebaseConfig in the script.", "error", 15000);
                return; 
            }

            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                try {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                }
            } else if (!auth.currentUser) { 
                console.log("No initial auth token, user needs to login/signup via form.");
            }
        }

        document.addEventListener('DOMContentLoaded', startApp);
    </script>
</body>
</html>
