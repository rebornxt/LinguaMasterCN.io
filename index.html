<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HanziFlow - Learn Chinese</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Custom Colors for Modern Chinese Aesthetic */
        :root {
            --modern-red: #C0392B; /* Pomegranate */
            --modern-red-darker: #A93226; /* Darker Pomegranate for hover */
            --accent-gold: #B08D57; /* Muted Gold/Bronze */
            --accent-gold-lighter: #D4AF37; /* Lighter Gold for active/hover */
            --bg-off-white: #FDFBF5; /* Warm Off-White */
            --text-dark-gray: #34495E; /* Wet Asphalt */
            --border-light-gray: #EAEAEA; /* Softer light gray */
            --subtle-bg: #F8F6F0; /* Very subtle bg for contrast */
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            overscroll-behavior-y: contain; 
            background-color: var(--bg-off-white);
            color: var(--text-dark-gray);
        }
        .chinese-char {
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 2.2rem; 
            line-height: 1.2;
            min-height: 2.6rem; 
            color: var(--text-dark-gray);
        }
        .chinese-char-quiz {
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 2rem;
            line-height: 1.2;
            min-height: 2.4rem; 
            color: var(--text-dark-gray);
        }
        .pinyin-text {
            font-size: 0.9rem; 
            color: #7f8c8d; /* Grayish blue for pinyin */
            min-height: 1.1rem;
        }
        .translation-text {
            font-size: 1rem; 
            min-height: 1.2rem;
            color: var(--text-dark-gray);
        }
        .flip-card {
            perspective: 1000px;
        }
        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }
        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px; /* Increased padding slightly for content */
            border-radius: 0.75rem; /* Softer, larger rounded corners (rounded-xl) */
            box-shadow: 0 6px 12px -2px rgba(50, 50, 93, 0.15), 0 3px 7px -3px rgba(0, 0, 0, 0.15); /* Softer shadow */
            border: 1px solid var(--border-light-gray);
        }
        .flip-card-front {
            background-color: white; /* Keep front clean white */
            justify-content: center; 
        }
        .flip-card-back {
            background-color: var(--subtle-bg); /* Subtle bg for back */
            transform: rotateY(180deg);
            justify-content: space-between; 
        }
        .btn {
            padding: 0.6rem 1.2rem; /* Slightly more horizontal padding */
            border-radius: 0.5rem; /* rounded-lg */
            font-weight: 500; 
            transition: background-color 0.2s, opacity 0.2s, transform 0.1s;
            cursor: pointer;
            border: 1px solid transparent;
            text-align: center; 
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-1px); /* Subtle lift on hover */
        }
        .btn:active:not(:disabled) {
            transform: translateY(0px);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .btn-theme-primary { /* New primary button style */
            background-color: var(--modern-red); 
            color: white;
            border-color: var(--modern-red);
        }
        .btn-theme-primary:hover:not(:disabled) {
            background-color: var(--modern-red-darker); 
            border-color: var(--modern-red-darker);
        }
        .btn-theme-secondary { /* New secondary button style */
            background-color: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        .btn-theme-secondary:hover:not(:disabled) {
            background-color: var(--accent-gold-lighter);
            border-color: var(--accent-gold-lighter);
        }
        .btn-theme-danger { /* For reset button */
            background-color: #D9534F; /* A slightly softer red for danger */
            color: white;
        }
        .btn-theme-danger:hover:not(:disabled) {
            background-color: #C9302C;
        }
        .btn-theme-outline {
            background-color: transparent;
            color: var(--modern-red); 
            border-color: var(--modern-red); 
        }
        .btn-theme-outline:hover:not(:disabled) {
            background-color: rgba(192, 57, 43, 0.05); /* Very light red bg on hover */
        }
        .btn-toggle.active { /* Active toggle buttons */
            background-color: var(--accent-gold); 
            color: white;
            border-color: var(--accent-gold);
        }
        .btn-toggle-group {
            gap: 0.25rem; 
        }
        .btn-toggle-group button { /* Default state for toggle buttons */
            background-color: white;
            color: var(--text-dark-gray);
            border: 1px solid var(--border-light-gray);
        }
        .btn-toggle-group button:hover:not(.active):not(:disabled) {
             background-color: var(--subtle-bg);
        }

        .quiz-choice.correct {
            background-color: #d1fae5; 
            border-color: #10b981; 
            color: #065f46; 
        }
        .quiz-choice.incorrect {
            background-color: #fee2e2; 
            border-color: #ef4444; 
            color: #b91c1c; 
        }
        .quiz-choice.reveal-correct {
            background-color: #a7f3d0; 
            border-color: #059669;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        #messageBox {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 1rem 1.5rem; border-radius: 0.375rem; color: white;
            z-index: 1000; opacity: 0; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            min-width: 250px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #messageBox.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        #messageBox.success { background-color: #10b981; }
        #messageBox.error { background-color: #ef4444; }
        #messageBox.info { background-color: var(--modern-red); } /* Info uses primary red */

        #controlPanel {
            max-height: 0; overflow: hidden; transition: max-height 0.5s ease-in-out;
            background-color: white; /* Keep control panel clean */
            border: 1px solid var(--border-light-gray);
            border-radius: 0.75rem; /* rounded-xl */
        }
         #controlPanel.open { max-height: 1000px; }
        .loading-placeholder { color: #9ca3af; font-style: italic; }
        .bar-container {
            width: 100%; background-color: #e5e7eb; 
            border-radius: 9999px; height: 0.625rem; overflow: hidden; 
        }
        .bar-fill { height: 100%; border-radius: 9999px; transition: width 0.3s ease-in-out; }
        
        #controlPanel > div:not(:last-child) { margin-bottom: 1rem; }
        #controlPanel > p { margin-top: 0.25rem; margin-bottom: 0.5rem; }
        .flashcard-back-content-wrapper {
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; flex-grow: 1; 
        }
        /* Header Styling */
        header h1 { color: var(--modern-red); }
        header h1 span { color: var(--accent-gold); }
        header p { color: #7f8c8d; }

        /* Footer Styling */
        footer { border-top-color: var(--border-light-gray); }
        footer .text-slate-600 { color: #7f8c8d; } /* Lighter text for footer stats */
        footer .bar-fill#progressBar { background-color: var(--modern-red); }
        footer .bar-fill#accuracyBar { background-color: var(--accent-gold); }
        footer .text-slate-400 { color: #95a5a6; } /* Version text */

    </style>
</head>
<body class="selection:bg-red-100"> <div id="messageBox"></div>

    <header class="w-full max-w-4xl mb-8 text-center"> <div class="flex justify-center items-center mb-1"> <h1 class="text-3xl md:text-4xl font-bold">
                HanziFlow <span class="text-xl font-medium">汉字流</span>
            </h1>
        </div>
        <p class="text-sm">Master Chinese, one card at a time.</p>
         <button id="toggleControlsBtn" class="md:hidden absolute top-4 right-4 p-2 rounded-md hover:bg-gray-100">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-gray-600">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6h9.75M10.5 12h9.75m-9.75 6h9.75M3.75 6H6m-2.25 6H6m-2.25 6H6" />
            </svg>
        </button>
    </header>

    <div class="w-full max-w-4xl flex flex-col md:flex-row gap-6 px-2 sm:px-0">
        <aside id="controlPanelContainer" class="w-full md:w-1/3 lg:w-1/4">
            <div id="controlPanel" class="p-4 shadow-lg md:sticky md:top-8"> 
                <div>
                    <label class="block text-sm font-medium mb-1">Deck Source</label>
                    <div class="btn-toggle-group flex">
                        <button id="deckWordsBtn" class="btn flex-1 btn-toggle active">Words</button>
                        <button id="deckSentencesBtn" class="btn flex-1 btn-toggle">Sentences</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Mode</label>
                    <div class="btn-toggle-group flex">
                        <button id="modeFlashcardBtn" class="btn flex-1 btn-toggle active">Flashcard</button>
                        <button id="modeQuizBtn" class="btn flex-1 btn-toggle">Quiz</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Character Set</label>
                    <div class="btn-toggle-group flex">
                        <button id="charSimplifiedBtn" class="btn flex-1 btn-toggle active">Simplified</button>
                        <button id="charTraditionalBtn" class="btn flex-1 btn-toggle">Traditional</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Pinyin</label>
                    <div class="btn-toggle-group flex">
                        <button id="pinyinShowBtn" class="btn flex-1 btn-toggle active">Show</button>
                        <button id="pinyinHideBtn" class="btn flex-1 btn-toggle">Hide</button>
                    </div>
                </div>
                <div id="quizTranslationToggleContainer">
                    <label class="block text-sm font-medium mb-1">Quiz Choices</label>
                    <div class="btn-toggle-group flex">
                        <button id="transEnBtn" class="btn flex-1 btn-toggle active">English</button>
                        <button id="transThBtn" class="btn flex-1 btn-toggle">Thai</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Deck View</label>
                    <div class="btn-toggle-group flex flex-wrap"> 
                        <button id="deckAllBtn" class="btn flex-grow sm:flex-1 btn-toggle active mb-1 sm:mb-0">All</button>
                        <button id="deckReviewBtn" class="btn flex-grow sm:flex-1 btn-toggle mb-1 sm:mb-0">Review</button>
                        <button id="deckUnlearnedBtn" class="btn flex-grow sm:flex-1 btn-toggle">Unlearned</button>
                    </div>
                </div>
                 <p id="reviewDeckCount" class="text-xs text-center">Review: 0</p>
                 <p id="learnedDeckCount" class="text-xs text-center">Learned: 0</p>
                <div class="flex items-center justify-between">
                    <label for="autoAdvanceToggle" class="text-sm font-medium">Auto-Advance</label>
                    <button id="autoAdvanceToggle" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200">
                        <span class="sr-only">Auto-Advance</span>
                        <span id="autoAdvanceToggleKnob" class="inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out translate-x-1"></span>
                    </button>
                </div>
            </div>
        </aside>

        <main class="w-full md:w-2/3 lg:w-3/4 flex-1">
            <div id="flashcardMode" class="h-72 md:h-80"> 
                <div id="flashcard" class="flip-card w-full h-full">
                    <div class="flip-card-inner">
                        <div id="flashcardFront" class="flip-card-front">
                            <div id="flashcardChar" class="chinese-char mb-1"></div>
                            <div id="flashcardPinyin" class="pinyin-text"></div>
                        </div>
                        <div id="flashcardBack" class="flip-card-back">
                            <div class="flashcard-back-content-wrapper">
                                <div id="flashcardEn" class="translation-text mb-1 font-semibold"></div>
                                <div id="flashcardTh" class="translation-text mb-1"></div>
                                <div id="flashcardPinyinBack" class="pinyin-text mt-1"></div>
                            </div>
                            <div id="flashcardFeedbackButtons" class="w-full flex flex-col sm:flex-row sm:justify-center gap-2 sm:gap-3 pt-3">
                                <button id="reviewAgainBtn" class="btn btn-theme-outline flex-1">Review Again</button>
                                <button id="rememberBtn" class="btn btn-theme-outline flex-1" style="color: var(--accent-gold); border-color: var(--accent-gold);">I Remember It</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="quizMode" class="hidden bg-white p-6 rounded-xl shadow-lg border border-[var(--border-light-gray)]">
                <div id="quizQuestionArea" class="text-center mb-6">
                    <div id="quizChar" class="chinese-char-quiz mb-1"></div>
                    <div id="quizPinyin" class="pinyin-text"></div>
                </div>
                <div id="quizChoicesArea" class="grid grid-cols-1 sm:grid-cols-2 gap-3"></div>
                <div id="quizFeedback" class="mt-4 text-center font-semibold"></div>
            </div>

            <div id="navigationButtons" class="mt-6 flex flex-col space-y-2 sm:flex-row sm:space-y-0 sm:justify-center sm:gap-3">
                <button id="prevBtn" class="btn btn-theme-secondary w-full sm:w-auto">Previous</button>
                <button id="nextBtn" class="btn btn-theme-secondary w-full sm:w-auto">Next</button>
            </div>
        </main>
    </div>
    
    <div class="w-full max-w-4xl mt-8 flex flex-col sm:flex-row justify-center items-center gap-3">
        <button id="shuffleDeckBtn" class="btn btn-theme-primary w-full sm:w-auto">Shuffle Current Deck</button>
        <button id="resetProgressBtn" class="btn btn-theme-danger w-full sm:w-auto">Reset All Progress</button>
    </div>

    <footer class="w-full max-w-4xl mt-6 pt-6 border-t"> 
        <div class="grid grid-cols-2 gap-x-4 gap-y-2 items-center text-sm mb-2"> 
            <div>Progress: <span id="progressText">0/0</span></div>
            <div id="accuracyDisplayContainer" class="text-right">Accuracy: <span id="accuracyText">N/A</span></div>
            <div class="bar-container">
                <div id="progressBar" class="bar-fill"></div>
            </div>
            <div class="bar-container">
                <div id="accuracyBar" class="bar-fill"></div>
            </div>
        </div>
         <p class="text-xs text-center mt-4">HanziFlow v1.6 - Modern Chinese Aesthetic</p>
    </footer>

    <script>
        // --- DATA URLs ---
        const DATA_URLS = {
            words: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRtb5XXT0vCnmLWPrtrFYXp8gcLpg9AKusdIx4KiMLbmWCGhgcUCuq0J4x8fr_Tq3afGFxd3u8cAzEc/pub?gid=961444178&single=true&output=csv',
            sentences: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRtb5XXT0vCnmLWPrtrFYXp8gcLpg9AKusdIx4KiMLbmWCGhgcUCuq0J4x8fr_Tq3afGFxd3u8cAzEc/pub?gid=156031206&single=true&output=csv'
        };

        // --- STATE VARIABLES ---
        let appState = {
            deckSource: 'words', 
            currentMode: 'flashcard', 
            showSimplified: true, 
            showPinyin: true,
            quizTranslationLanguage: 'en', 
            deckViewType: 'all', 
            autoAdvance: false,
            masterDeck: [], 
            currentDeck: [], 
            progress: { 
                words: { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false },
                sentences: { currentIndex: 0, quizAttempts: 0, quizCorrect: 0, reviewIds: new Set(), learnedIds: new Set(), quizAnsweredCurrent: false }
            },
            isFlashcardFlipped: false,
            controlPanelOpen: false,
            isLoading: false,
        };

        const el = {}; 

        // --- UTILITY FUNCTIONS ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showMessage(text, type = 'info', duration = 3000) {
            el.messageBox.textContent = text;
            el.messageBox.className = ''; 
            el.messageBox.classList.add('show', type);
            setTimeout(() => {
                el.messageBox.classList.remove('show');
            }, duration);
        }
        
        // --- DATA FETCHING AND PARSING ---
        async function fetchCSVData(url, idPrefix) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network response: ${response.statusText}`);
                const csvText = await response.text();
                return parseCSVToObjects(csvText, idPrefix);
            } catch (error) {
                console.error('Failed to fetch/parse CSV:', error);
                showMessage(`Error loading deck: ${error.message}`, 'error', 5000);
                return [];
            }
        }

        function parseCSVToObjects(csvText, idPrefix) {
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length <= 1) return []; 
            const dataObjects = [];
            for (let i = 1; i < lines.length; i++) { 
                if (lines[i].trim() === '') continue; 
                
                const values = lines[i].split(','); 
                if (values.length >= 5) { 
                    dataObjects.push({
                        id: `${idPrefix}${i}`, 
                        s: values[0]?.trim()||'', 
                        t: values[1]?.trim()||'', 
                        p: values[2]?.trim()||'', 
                        en: values[3]?.trim()||'', 
                        th: values[4]?.trim()||''
                    });
                } else console.warn(`Skipping malformed CSV line ${i+1}: ${lines[i]}`);
            }
            return dataObjects;
        }
        
        // --- LOCAL STORAGE PERSISTENCE ---
        function getDeckState() {
            return appState.progress[appState.deckSource];
        }

        function loadStateFromLocalStorage() {
            ['words', 'sentences'].forEach(source => {
                const reviewKey = `reviewDeckIds_${source}`;
                const learnedKey = `learnedDeckIds_${source}`;
                const quizAttemptsKey = `quizAttempts_${source}`;
                const quizCorrectKey = `quizCorrect_${source}`;

                const storedReviewIds = localStorage.getItem(reviewKey);
                const storedLearnedIds = localStorage.getItem(learnedKey);
                const storedQuizAttempts = localStorage.getItem(quizAttemptsKey);
                const storedQuizCorrect = localStorage.getItem(quizCorrectKey);

                if (storedReviewIds) appState.progress[source].reviewIds = new Set(JSON.parse(storedReviewIds));
                if (storedLearnedIds) appState.progress[source].learnedIds = new Set(JSON.parse(storedLearnedIds));
                if (storedQuizAttempts) appState.progress[source].quizAttempts = parseInt(storedQuizAttempts, 10) || 0;
                if (storedQuizCorrect) appState.progress[source].quizCorrect = parseInt(storedQuizCorrect, 10) || 0;
                appState.progress[source].quizAnsweredCurrent = false; 
            });
        }

        function saveStateToLocalStorage() {
            const source = appState.deckSource;
            const deckState = getDeckState();
            localStorage.setItem(`reviewDeckIds_${source}`, JSON.stringify(Array.from(deckState.reviewIds)));
            localStorage.setItem(`learnedDeckIds_${source}`, JSON.stringify(Array.from(deckState.learnedIds)));
            localStorage.setItem(`quizAttempts_${source}`, deckState.quizAttempts.toString());
            localStorage.setItem(`quizCorrect_${source}`, deckState.quizCorrect.toString());
        }


        // --- INITIALIZATION AND DATA LOADING ---
        async function initializeDeck(isSourceChange = false) {
            appState.isLoading = true;
            setLoadingState(true);
            
            const url = DATA_URLS[appState.deckSource];
            const idPrefix = appState.deckSource === 'words' ? 'w' : 's';
            
            appState.masterDeck = await fetchCSVData(url, idPrefix);
            shuffleArray(appState.masterDeck); 
            
            appState.isLoading = false;
            setLoadingState(false);

            if (appState.masterDeck.length === 0 && url) { 
                 showMessage(`No items found in ${appState.deckSource} deck. Check data source.`, 'error', 5000);
            }
            
            const currentDeckState = getDeckState();
            currentDeckState.currentIndex = 0; 
            currentDeckState.quizAnsweredCurrent = false; 
            
            filterAndSetCurrentDeck(); 
            updateDisplay();
        }
        
        function setLoadingState(isLoading) {
            appState.isLoading = isLoading;
            const loadingText = "Loading deck...";
            if (isLoading) {
                if (appState.currentMode === 'flashcard') {
                    el.flashcardChar.textContent = loadingText;
                    el.flashcardChar.classList.add('loading-placeholder');
                    el.flashcardPinyin.textContent = ''; el.flashcardEn.textContent = ''; el.flashcardTh.textContent = '';
                } else {
                    el.quizChar.textContent = loadingText;
                    el.quizChar.classList.add('loading-placeholder');
                    el.quizPinyin.textContent = ''; el.quizChoicesArea.innerHTML = '';
                }
                Object.values(el.controlPanel.querySelectorAll('button')).forEach(btn => btn.disabled = true);
                el.shuffleDeckBtn.disabled = true;
                el.resetProgressBtn.disabled = true;
            } else {
                 el.flashcardChar.classList.remove('loading-placeholder');
                 el.quizChar.classList.remove('loading-placeholder');
                 Object.values(el.controlPanel.querySelectorAll('button')).forEach(btn => btn.disabled = false);
                 el.shuffleDeckBtn.disabled = appState.currentDeck.length === 0; 
                 el.resetProgressBtn.disabled = false;
            }
            updateDisplay();
        }

        function filterAndSetCurrentDeck() {
            const deckState = getDeckState();
            let deckToUse = [];

            if (appState.deckViewType === 'all') {
                deckToUse = [...appState.masterDeck]; 
            } else if (appState.deckViewType === 'review') {
                deckToUse = appState.masterDeck.filter(item => deckState.reviewIds.has(item.id));
                shuffleArray(deckToUse); 
            } else if (appState.deckViewType === 'unlearned') {
                deckToUse = appState.masterDeck.filter(item => !deckState.learnedIds.has(item.id));
                shuffleArray(deckToUse); 
            }
            
            appState.currentDeck = deckToUse;
            el.shuffleDeckBtn.disabled = appState.isLoading || appState.currentDeck.length === 0;


            if (deckState.currentIndex >= appState.currentDeck.length) {
                deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
            }
             if (appState.currentDeck.length === 0 && appState.masterDeck.length > 0) {
                const viewName = appState.deckViewType.charAt(0).toUpperCase() + appState.deckViewType.slice(1);
                showMessage(`${viewName} deck is empty.`, "info");
            }
        }

        // --- DISPLAY UPDATE FUNCTIONS ---
        function updateDisplay() {
            updateToggleButtonStates();
            updateModeVisibility(); 
            updateNavigationButtons();
            updateProgressAndAccuracy(); 
            updateStatusCounts();       

            if (appState.isLoading) {
                el.prevBtn.disabled = true; el.nextBtn.disabled = true;
                if(el.quizChoicesArea) el.quizChoicesArea.innerHTML = '';
                return;
            }
            
            const deckState = getDeckState();
            if (appState.currentDeck.length === 0) {
                const msg = appState.deckViewType.charAt(0).toUpperCase() + appState.deckViewType.slice(1) + " Deck Empty";
                if (appState.currentMode === 'flashcard') {
                    el.flashcardChar.textContent = msg; el.flashcardPinyin.textContent = '';
                    el.flashcardEn.textContent = ''; el.flashcardTh.textContent = ''; el.flashcardPinyinBack.textContent = '';
                    el.flashcard.classList.remove('flipped'); appState.isFlashcardFlipped = false;
                } else { 
                    el.quizChar.textContent = msg; el.quizPinyin.textContent = '';
                    el.quizChoicesArea.innerHTML = ''; el.quizFeedback.textContent = '';
                }
                el.prevBtn.disabled = true; el.nextBtn.disabled = true;
                return; 
            }
            
            if (deckState.currentIndex >= appState.currentDeck.length) {
                 deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1); 
            }
            if (deckState.currentIndex < 0 && appState.currentDeck.length > 0) deckState.currentIndex = 0;


            const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) {
                 console.error("Current item is undefined. Index:", deckState.currentIndex, "Deck:", appState.currentDeck);
                 el.flashcardChar.textContent = 'Error.'; 
                 el.prevBtn.disabled = true; el.nextBtn.disabled = true;
                 return;
            }

            const charToDisplay = appState.showSimplified ? currentItem.s : currentItem.t;
            const pinyinToDisplay = appState.showPinyin ? currentItem.p : '';

            if (appState.currentMode === 'flashcard') {
                el.flashcardChar.textContent = charToDisplay; el.flashcardPinyin.textContent = pinyinToDisplay;
                el.flashcardEn.textContent = currentItem.en; el.flashcardTh.textContent = currentItem.th;
                el.flashcardPinyinBack.textContent = pinyinToDisplay; 
                el.flashcard.classList.toggle('flipped', appState.isFlashcardFlipped);
            } else { 
                el.quizChar.textContent = charToDisplay; el.quizPinyin.textContent = pinyinToDisplay;
                if (!deckState.quizAnsweredCurrent) { 
                    renderQuizChoices(currentItem);
                    el.quizFeedback.textContent = '';
                }
            }
        }

        function updateToggleButtonStates() {
            el.deckWordsBtn.classList.toggle('active', appState.deckSource === 'words');
            el.deckSentencesBtn.classList.toggle('active', appState.deckSource === 'sentences');
            el.modeFlashcardBtn.classList.toggle('active', appState.currentMode === 'flashcard');
            el.modeQuizBtn.classList.toggle('active', appState.currentMode === 'quiz');
            el.charSimplifiedBtn.classList.toggle('active', appState.showSimplified);
            el.charTraditionalBtn.classList.toggle('active', !appState.showSimplified);
            el.pinyinShowBtn.classList.toggle('active', appState.showPinyin);
            el.pinyinHideBtn.classList.toggle('active', !appState.showPinyin);
            el.transEnBtn.classList.toggle('active', appState.quizTranslationLanguage === 'en');
            el.transThBtn.classList.toggle('active', appState.quizTranslationLanguage === 'th');
            
            el.deckAllBtn.classList.toggle('active', appState.deckViewType === 'all');
            el.deckReviewBtn.classList.toggle('active', appState.deckViewType === 'review');
            el.deckUnlearnedBtn.classList.toggle('active', appState.deckViewType === 'unlearned');

            el.autoAdvanceToggle.classList.toggle('bg-[var(--modern-red)]', appState.autoAdvance); // Use theme color
            el.autoAdvanceToggle.classList.toggle('bg-gray-200', !appState.autoAdvance);
            el.autoAdvanceToggleKnob.classList.toggle('translate-x-5', appState.autoAdvance);
            el.autoAdvanceToggleKnob.classList.toggle('translate-x-1', !appState.autoAdvance);
        }

        function updateModeVisibility() {
            const isFlashcard = appState.currentMode === 'flashcard';
            el.flashcardModeDiv.classList.toggle('hidden', !isFlashcard);
            el.quizModeDiv.classList.toggle('hidden', isFlashcard);
            el.quizTranslationToggleContainer.classList.toggle('hidden', isFlashcard); 
            el.accuracyDisplayContainer.classList.toggle('hidden', isFlashcard); 
            
            // Flashcard feedback buttons are part of the card back, their visibility is tied to flip state
            // and whether we are in flashcard mode. No explicit show/hide needed here beyond that.
            
            if (!appState.isLoading) getDeckState().quizAnsweredCurrent = false; 
        }

        function updateNavigationButtons() {
            el.navigationButtons.classList.toggle('hidden', appState.autoAdvance || appState.isLoading);
            const deckState = getDeckState();
            if (appState.currentDeck.length === 0 || appState.isLoading) {
                el.prevBtn.disabled = true; el.nextBtn.disabled = true;
            } else {
                el.prevBtn.disabled = deckState.currentIndex === 0;
                el.nextBtn.disabled = deckState.currentIndex === appState.currentDeck.length - 1;
            }
        }

        function updateProgressAndAccuracy() {
            const deckState = getDeckState();
            const totalItems = appState.currentDeck.length;
            const reviewedItems = totalItems > 0 ? deckState.currentIndex + 1 : 0;
            
            el.progressText.textContent = `${reviewedItems}/${totalItems}`;
            el.progressBar.style.width = totalItems > 0 ? `${(reviewedItems / totalItems) * 100}%` : '0%';

            if (appState.currentMode === 'quiz') {
                const accuracy = deckState.quizAttempts > 0 ?
                    ((deckState.quizCorrect / deckState.quizAttempts) * 100) : 0; 
                el.accuracyText.textContent = deckState.quizAttempts > 0 ? `${accuracy.toFixed(0)}%` : 'N/A';
                el.accuracyBar.style.width = `${accuracy}%`;
            } else {
                 el.accuracyText.textContent = 'N/A';
                 el.accuracyBar.style.width = '0%';
            }
        }
        
        function updateStatusCounts() {
            const deckState = getDeckState();
            el.reviewDeckCount.textContent = `Review: ${deckState.reviewIds.size}`;
            el.learnedDeckCount.textContent = `Learned: ${deckState.learnedIds.size}`;
        }

        // --- FLASHCARD MODE LOGIC ---
        function flipCard() {
            if (appState.isLoading || appState.currentDeck.length === 0) return;
            appState.isFlashcardFlipped = !appState.isFlashcardFlipped;
            el.flashcard.classList.toggle('flipped', appState.isFlashcardFlipped);
        }

        function handleFlashcardFeedback(isRemembered) {
            if (appState.isLoading) return;
            const deckState = getDeckState();
            const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) return; 

            const charText = appState.showSimplified ? currentItem.s : currentItem.t;

            if (isRemembered) {
                showMessage(`"${charText}" marked as remembered.`, 'success', 1500);
                deckState.learnedIds.add(currentItem.id);
                deckState.reviewIds.delete(currentItem.id); 
            } else { 
                showMessage(`"${charText}" added to review.`, 'info', 1500);
                deckState.reviewIds.add(currentItem.id);
                deckState.learnedIds.delete(currentItem.id); 
            }
            saveStateToLocalStorage(); 
            updateStatusCounts(); 

            let deckNeedsRefilter = false;
            if (appState.deckViewType === 'unlearned' && isRemembered) {
                deckNeedsRefilter = true;
            } 
            else if (appState.deckViewType === 'review' && isRemembered) { 
                deckNeedsRefilter = true;
            }


            if (appState.autoAdvance) {
                if (deckNeedsRefilter) {
                    setTimeout(() => {
                        const oldIndex = deckState.currentIndex;
                        filterAndSetCurrentDeck(); 
                        
                        if (appState.currentDeck.length > 0) {
                            if (oldIndex < appState.currentDeck.length) {
                                deckState.currentIndex = oldIndex; 
                            } else { 
                                deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
                            }
                            if (deckState.currentIndex < appState.currentDeck.length -1 || (appState.currentDeck.length === 1 && deckState.currentIndex === 0) ) {
                                if (appState.currentDeck.length > 0 && oldIndex === appState.currentDeck.length && isRemembered && appState.deckViewType !== 'all') { 
                                     showMessage("End of filtered deck.", "info");
                                     updateDisplay();
                                } else {
                                   goToNextItem();
                                }
                            } else { 
                                showMessage("End of filtered deck.", "info");
                                updateDisplay(); 
                            }
                        } else { 
                             updateDisplay(); 
                        }
                    }, 600); 
                } else { 
                    setTimeout(goToNextItem, 500);
                }
            } else if (deckNeedsRefilter) { 
                const oldIndex = deckState.currentIndex;
                filterAndSetCurrentDeck();
                if (appState.currentDeck.length > 0) { 
                    if (oldIndex < appState.currentDeck.length) {
                        deckState.currentIndex = oldIndex;
                    } else {
                         deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
                    }
                }
                updateDisplay(); 
            }
        }

        // --- QUIZ MODE LOGIC ---
        function renderQuizChoices(currentItem) {
            el.quizChoicesArea.innerHTML = ''; 
            const correctAnswerLang = appState.quizTranslationLanguage === 'en' ? currentItem.en : currentItem.th;
            let choices = [correctAnswerLang];

            const distractors = appState.masterDeck 
                .filter(item => item.id !== currentItem.id) 
                .map(item => appState.quizTranslationLanguage === 'en' ? item.en : item.th) 
                .filter((value, index, self) => value && self.indexOf(value) === index && value !== correctAnswerLang); 

            shuffleArray(distractors);
            const numDistractors = Math.min(3, distractors.length); 
            choices = choices.concat(distractors.slice(0, numDistractors)); 
            shuffleArray(choices); 

            choices.forEach(choiceText => {
                const choiceButton = document.createElement('button');
                // Use new theme outline for quiz choices by default
                choiceButton.className = 'btn btn-theme-outline w-full text-left p-3 quiz-choice';
                choiceButton.textContent = choiceText;
                choiceButton.onclick = () => handleQuizAnswer(choiceText === correctAnswerLang, choiceButton, correctAnswerLang);
                el.quizChoicesArea.appendChild(choiceButton);
            });
        }

        function handleQuizAnswer(isCorrect, clickedButton, correctAnswerText) {
            const deckState = getDeckState();
            if (deckState.quizAnsweredCurrent || appState.isLoading) return; 

            deckState.quizAnsweredCurrent = true;
            deckState.quizAttempts++;
            const currentItem = appState.currentDeck[deckState.currentIndex];
            if (!currentItem) return; 
            const charText = appState.showSimplified ? currentItem.s : currentItem.t;
            let deckNeedsRefilter = false;

            if (isCorrect) {
                deckState.quizCorrect++;
                el.quizFeedback.textContent = 'Correct! 🎉';
                el.quizFeedback.className = 'mt-4 text-center font-semibold text-green-600';
                // Override default outline for correct
                clickedButton.className = 'btn w-full text-left p-3 quiz-choice correct'; // Keep existing correct class
                showMessage('Correct!', 'success', 1500);
                deckState.learnedIds.add(currentItem.id);
                deckState.reviewIds.delete(currentItem.id);
                if (appState.deckViewType === 'unlearned') deckNeedsRefilter = true;

            } else { 
                el.quizFeedback.innerHTML = `Incorrect. Correct: <span class="font-bold">${correctAnswerText}</span>`;
                el.quizFeedback.className = 'mt-4 text-center font-semibold text-red-600';
                 // Override default outline for incorrect
                clickedButton.className = 'btn w-full text-left p-3 quiz-choice incorrect'; // Keep existing incorrect class
                Array.from(el.quizChoicesArea.children).forEach(btn => {
                    if (btn.textContent === correctAnswerText) {
                        // Override for revealed correct
                        btn.className = 'btn w-full text-left p-3 quiz-choice reveal-correct';
                    }
                    btn.disabled = true; 
                });
                deckState.reviewIds.add(currentItem.id);
                deckState.learnedIds.delete(currentItem.id); 
                showMessage(`Added "${charText}" to review.`, 'error', 2000);
            }
            saveStateToLocalStorage(); 
            updateStatusCounts(); 
            updateProgressAndAccuracy(); 

            if (appState.autoAdvance) {
                 if (deckNeedsRefilter) {
                    setTimeout(() => {
                        const oldIndex = deckState.currentIndex;
                        filterAndSetCurrentDeck();
                        if (appState.currentDeck.length > 0) {
                             if (oldIndex < appState.currentDeck.length) { 
                                deckState.currentIndex = oldIndex;
                            } else { 
                                deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
                            }
                            if (deckState.currentIndex < appState.currentDeck.length -1 || (appState.currentDeck.length === 1 && deckState.currentIndex === 0) || (!isCorrect && deckState.currentIndex <= appState.currentDeck.length -1) ) {
                                 if (appState.currentDeck.length > 0 && oldIndex === appState.currentDeck.length && isCorrect && appState.deckViewType !== 'all') {
                                     showMessage("End of filtered deck.", "info");
                                     updateDisplay();
                                } else {
                                   goToNextItem();
                                }
                            } else {
                                showMessage("End of filtered deck.", "info");
                                updateDisplay();
                            }
                        } else { 
                             updateDisplay();
                        }
                    }, isCorrect ? 1600 : 2600); 
                } else { 
                    setTimeout(goToNextItem, isCorrect ? 1500 : 2500); 
                }
            } else if (deckNeedsRefilter) { 
                 const oldIndex = deckState.currentIndex;
                 filterAndSetCurrentDeck();
                 if (appState.currentDeck.length > 0) { 
                    if (oldIndex < appState.currentDeck.length) {
                        deckState.currentIndex = oldIndex;
                    } else {
                         deckState.currentIndex = Math.max(0, appState.currentDeck.length - 1);
                    }
                }
                 updateDisplay(); 
            }
        }

        // --- NAVIGATION LOGIC ---
        function goToNextItem() {
            if (appState.isLoading) return;
            const deckState = getDeckState();
            if (deckState.currentIndex < appState.currentDeck.length - 1) {
                deckState.currentIndex++;
                appState.isFlashcardFlipped = false; 
                deckState.quizAnsweredCurrent = false; 
                updateDisplay();
            } else if (appState.currentDeck.length > 0) { 
                showMessage("You've reached the end of the deck!", "info");
            }
        }

        function goToPrevItem() {
            if (appState.isLoading) return;
            const deckState = getDeckState();
            if (deckState.currentIndex > 0) {
                deckState.currentIndex--;
                appState.isFlashcardFlipped = false;
                deckState.quizAnsweredCurrent = false;
                updateDisplay();
            }
        }
        
        // --- DOM Element Setup ---
        function setupDOMReferences() {
            el.deckWordsBtn = document.getElementById('deckWordsBtn');
            el.deckSentencesBtn = document.getElementById('deckSentencesBtn');
            el.modeFlashcardBtn = document.getElementById('modeFlashcardBtn');
            el.modeQuizBtn = document.getElementById('modeQuizBtn');
            el.charSimplifiedBtn = document.getElementById('charSimplifiedBtn');
            el.charTraditionalBtn = document.getElementById('charTraditionalBtn');
            el.pinyinShowBtn = document.getElementById('pinyinShowBtn');
            el.pinyinHideBtn = document.getElementById('pinyinHideBtn');
            el.quizTranslationToggleContainer = document.getElementById('quizTranslationToggleContainer');
            el.transEnBtn = document.getElementById('transEnBtn');
            el.transThBtn = document.getElementById('transThBtn');
            
            el.deckAllBtn = document.getElementById('deckAllBtn');
            el.deckReviewBtn = document.getElementById('deckReviewBtn');
            el.deckUnlearnedBtn = document.getElementById('deckUnlearnedBtn');
            el.reviewDeckCount = document.getElementById('reviewDeckCount');
            el.learnedDeckCount = document.getElementById('learnedDeckCount');

            el.autoAdvanceToggle = document.getElementById('autoAdvanceToggle');
            el.autoAdvanceToggleKnob = document.getElementById('autoAdvanceToggleKnob');
            
            el.shuffleDeckBtn = document.getElementById('shuffleDeckBtn');
            el.resetProgressBtn = document.getElementById('resetProgressBtn');

            el.flashcardModeDiv = document.getElementById('flashcardMode');
            el.quizModeDiv = document.getElementById('quizMode');
            el.flashcard = document.getElementById('flashcard');
            el.flashcardFront = document.getElementById('flashcardFront');
            el.flashcardChar = document.getElementById('flashcardChar');
            el.flashcardPinyin = document.getElementById('flashcardPinyin');
            el.flashcardBack = document.getElementById('flashcardBack');
            el.flashcardEn = document.getElementById('flashcardEn');
            el.flashcardTh = document.getElementById('flashcardTh');
            el.flashcardPinyinBack = document.getElementById('flashcardPinyinBack');
            el.flashcardFeedbackButtons = document.getElementById('flashcardFeedbackButtons'); 
            el.reviewAgainBtn = document.getElementById('reviewAgainBtn');
            el.rememberBtn = document.getElementById('rememberBtn');
            el.quizQuestionArea = document.getElementById('quizQuestionArea');
            el.quizChar = document.getElementById('quizChar');
            el.quizPinyin = document.getElementById('quizPinyin');
            el.quizChoicesArea = document.getElementById('quizChoicesArea');
            el.quizFeedback = document.getElementById('quizFeedback');
            el.navigationButtons = document.getElementById('navigationButtons');
            el.prevBtn = document.getElementById('prevBtn');
            el.nextBtn = document.getElementById('nextBtn');
            el.progressText = document.getElementById('progressText');
            el.progressBar = document.getElementById('progressBar');
            el.accuracyDisplayContainer = document.getElementById('accuracyDisplayContainer');
            el.accuracyText = document.getElementById('accuracyText');
            el.accuracyBar = document.getElementById('accuracyBar');
            el.messageBox = document.getElementById('messageBox');
            el.toggleControlsBtn = document.getElementById('toggleControlsBtn');
            el.controlPanel = document.getElementById('controlPanel'); 
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            el.deckWordsBtn.addEventListener('click', async () => {
                if (appState.isLoading || appState.deckSource === 'words') return;
                appState.deckSource = 'words';
                await initializeDeck(true); 
            });
            el.deckSentencesBtn.addEventListener('click', async () => {
                if (appState.isLoading || appState.deckSource === 'sentences') return;
                appState.deckSource = 'sentences';
                await initializeDeck(true); 
            });

            el.modeFlashcardBtn.addEventListener('click', () => {
                if (appState.isLoading) return;
                appState.currentMode = 'flashcard';
                appState.isFlashcardFlipped = false; 
                updateDisplay();
            });
            el.modeQuizBtn.addEventListener('click', () => {
                if (appState.isLoading) return;
                appState.currentMode = 'quiz';
                updateDisplay();
            });

            el.charSimplifiedBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showSimplified = true; updateDisplay();} });
            el.charTraditionalBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showSimplified = false; updateDisplay();} });
            el.pinyinShowBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showPinyin = true; updateDisplay();} });
            el.pinyinHideBtn.addEventListener('click', () => { if (!appState.isLoading) {appState.showPinyin = false; updateDisplay();} });

            el.transEnBtn.addEventListener('click', () => {
                if (appState.isLoading) return;
                appState.quizTranslationLanguage = 'en';
                getDeckState().quizAnsweredCurrent = false; 
                updateDisplay();
            });
            el.transThBtn.addEventListener('click', () => {
                if (appState.isLoading) return;
                appState.quizTranslationLanguage = 'th';
                getDeckState().quizAnsweredCurrent = false; 
                updateDisplay();
            });

            el.deckAllBtn.addEventListener('click', () => {
                if (appState.isLoading || appState.deckViewType === 'all') return;
                appState.deckViewType = 'all';
                getDeckState().currentIndex = 0; 
                filterAndSetCurrentDeck(); updateDisplay();
            });
            el.deckReviewBtn.addEventListener('click', () => {
                if (appState.isLoading || appState.deckViewType === 'review') return;
                appState.deckViewType = 'review';
                getDeckState().currentIndex = 0;
                filterAndSetCurrentDeck(); updateDisplay();
            });
            el.deckUnlearnedBtn.addEventListener('click', () => {
                if (appState.isLoading || appState.deckViewType === 'unlearned') return;
                appState.deckViewType = 'unlearned';
                getDeckState().currentIndex = 0;
                filterAndSetCurrentDeck(); updateDisplay();
            });
            
            el.autoAdvanceToggle.addEventListener('click', () => {
                if (appState.isLoading) return;
                appState.autoAdvance = !appState.autoAdvance;
                updateDisplay(); 
            });

            el.shuffleDeckBtn.addEventListener('click', () => {
                if (appState.isLoading || appState.currentDeck.length === 0) return;
                shuffleArray(appState.currentDeck); 
                getDeckState().currentIndex = 0; 
                appState.isFlashcardFlipped = false;
                getDeckState().quizAnsweredCurrent = false;
                showMessage("Current deck view shuffled!", "success", 1500);
                updateDisplay();
            });

            el.resetProgressBtn.addEventListener('click', () => {
                if (appState.isLoading) return;
                
                const userConfirmed = window.confirm("Are you sure you want to reset all progress for this deck (Words/Sentences)? This will clear learned items, review items, and quiz scores.");
                if (!userConfirmed) {
                    return;
                }

                const deckState = getDeckState();
                deckState.currentIndex = 0;
                deckState.quizAttempts = 0;
                deckState.quizCorrect = 0;
                deckState.learnedIds.clear();
                deckState.reviewIds.clear();
                deckState.quizAnsweredCurrent = false; 
                saveStateToLocalStorage(); 
                
                filterAndSetCurrentDeck(); 
                showMessage("All progress for this deck source has been reset.", "info");
                updateDisplay();
            });


            el.flashcard.addEventListener('click', (e) => {
                if (appState.isLoading) return;
                if (e.target.closest('#reviewAgainBtn') || e.target.closest('#rememberBtn')) {
                    return; 
                }
                if (appState.currentMode === 'flashcard' && appState.currentDeck.length > 0) {
                    flipCard();
                }
            });
            el.reviewAgainBtn.addEventListener('click', () => handleFlashcardFeedback(false));
            el.rememberBtn.addEventListener('click', () => handleFlashcardFeedback(true));

            el.prevBtn.addEventListener('click', goToPrevItem);
            el.nextBtn.addEventListener('click', goToNextItem);

            document.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || appState.isLoading) {
                    return; 
                }
                if (appState.autoAdvance && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ')) return; 

                if (e.key === 'ArrowLeft') goToPrevItem();
                else if (e.key === 'ArrowRight') goToNextItem();
                else if (e.key === ' ' && appState.currentMode === 'flashcard') { 
                    e.preventDefault(); 
                    flipCard();
                }
            });

            el.toggleControlsBtn.addEventListener('click', () => {
                appState.controlPanelOpen = !appState.controlPanelOpen;
                el.controlPanel.classList.toggle('open', appState.controlPanelOpen);
            });
            
            function checkScreenSizeForControls() {
                if (window.innerWidth >= 768) { 
                    el.controlPanel.classList.add('open'); 
                    el.controlPanel.style.maxHeight = ''; 
                } else {
                    if (!appState.controlPanelOpen) { 
                         el.controlPanel.classList.remove('open');
                    }
                }
            }
            window.addEventListener('resize', checkScreenSizeForControls);
            checkScreenSizeForControls(); 
        }

        // --- APP START ---
        async function startApp() {
            console.log("App starting...");
            setupDOMReferences(); 
            loadStateFromLocalStorage(); 
            await initializeDeck(); 
            setupEventListeners();
            showMessage("Welcome to HanziFlow!", "info", 2000);
        }

        document.addEventListener('DOMContentLoaded', startApp);

    </script>
</body>
</html>
